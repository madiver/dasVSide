Ctrl+Shift+Q:Cancel All:~ 1107:// ======================~0D~0A//  CANCEL ALL NON-S
TOP ORDERS + DELETE TP ALERTS (CURRENT SYMBOL)~0D~0A
// ======================~0D~0A~0D~0A// 0) Make sur
e we're on Primary_OE and can read it~0D~0AFocusWin
dow Primary_OE;~0D~0ACXL ALLSYMB;~0D~0A~0D~0A$M = G
etWindowObj("Primary_OE");~0D~0Aif (!IsObj($M)) {~0D
~0A    // If we can't access Primary_OE, we can't s
afely infer symbol/position~0D~0A    return;~0D~0A}
~0D~0A~0D~0A// Snapshot symbol and position BEFORE 
we cancel orders~0D~0A$mySym   = $M.Symb;~0D~0A$pos
Now  = $M.Pos;~0D~0A~0D~0A// LONG-ONLY: only rebuil
d stop if we have a long position~0D~0Aif ($posNow 
> 0 && $useAutoStop == "Yes" && $resetStopOnCancel 
== "Yes") {~0D~0A    ExecHotkey("Set Auto Stop");~0D
~0A}~0D~0A~0D~0A// Delete all TP alerts for this sy
mbol over a reasonable R range~0D~0A// This matches
 how the TP Alert Builder names them:~0D~0A// "TP "
 + <factor> + "R Partial " + <symbol>~0D~0A~0D~0A$i
 = 1;~0D~0A// i=1..20  ~E2~86~92 factors: 0.5, 1.0,
 1.5, ..., 10.0~0D~0Awhile ($i <= 20) {~0D~0A    $f
 = ($i * 0.5);   // 0.5, 1, 1.5, 2, ...~0D~0A~0D~0A
    $name = "TP " + $f + "R Partial " + $mySym;~0D~0A
~0D~0A    $al = GetAlertObj($name);~0D~0A    if (Is
Obj($al)) {~0D~0A        $al.Delete();~0D~0A    }~0D
~0A~0D~0A    $i = $i + 1;~0D~0A}~0D~0A~0D~0Areturn;
Alt+Ctrl+Q:GTFO:CXL ALL; FocusWindow Primary_OE; ROUTE="ARCAL"; TIF=DAY+; Price=Bid-0.50; Share=Pos; SELL=Send;~0D~0A
Ctrl+Shift+1:Buy 10 Bid+ SL:~ 7578:// =====================~0D~0A//  SCALING-AWARE ENT
RY~0D~0A// =====================~0D~0A~0D~0AFocusWi
ndow Primary_OE;~0D~0A~0D~0A// ---- Global daily-lo
ss guard per account ----~0D~0A$accName = GetVar("D
AY_ACC");~0D~0A$lockKey = "TRADING_LOCKED_" + $accN
ame;~0D~0A$locked  = GetVar($lockKey) * 1;~0D~0A~0D
~0Aif ($locked == 1) {~0D~0A    MsgBox("Trading loc
ked for " + $accName + " (daily loss limit hit).");
~0D~0A    return;~0D~0A}~0D~0A~0D~0A// Set ENTRY_SY
M and clear TP_SYMBOL~0D~0A$M = GetWindowObj("Prima
ry_OE");~0D~0Aif (IsObj($M)) {~0D~0A    $entrySymbo
l = $M.Symb;~0D~0A} else {~0D~0A    $entrySymbol = 
Symbol;~0D~0A}~0D~0A$tpSymbol = "";~0D~0A~0D~0A// -
-- Capture pre-entry position & average cost (for T
P logic) ---~0D~0A$posBefore = 0;~0D~0A$avgBefore =
 0;~0D~0A~0D~0Aif (IsObj($M)) {~0D~0A    $posBefore
 = $M.Pos;~0D~0A    $avgBefore = $M.AvgCost;~0D~0A}
 else {~0D~0A    $posBefore = Pos;~0D~0A    $avgBef
ore = AvgCost;~0D~0A}~0D~0A~0D~0Aif ($rehab ==1 && 
$M.Pos > 0 && $ACCOUNT_STATE == "live") {~0D~0A    
MsgBox("ABORTED: Rehab size violation, scaling in n
ot allowed!");~0D~0A    return;~0D~0A}~0D~0A~0D~0A/
/ Ice Breaker = 1/4 of normal share size~0D~0A$quar
ter = 50 * $qtyMult * 0.25;~0D~0A$scaled = $quarter
 + 2.5;~0D~0A$addShares = $scaled - ($scaled % 5);~0D
~0A~0D~0A// ---- Tunables ----~0D~0A$refPx         
    = BID;             // BID or ASK~0D~0A$minDelay
Ms  = 1000;           // throttle between order sen
ds (ms)~0D~0A~0D~0A// ---- Max position size guard 
rail ----~0D~0Aif ($maxPositionSize > 0) {    ~0D~0A
    // Determine current position in Primary_OE (fa
llback: Pos)~0D~0A    $curPos = 0;~0D~0A    if (IsO
bj($M)) {~0D~0A        $curPos = $M.Pos;~0D~0A    }
 else {~0D~0A        $curPos = Pos;        // DAS b
uilt-in position for current symbol~0D~0A    }~0D~0A
~0D~0A    // Remaining capacity before hitting the 
guard rail~0D~0A    $remaining = $maxPositionSize -
 $curPos;~0D~0A~0D~0A    // If we're already at / a
bove max, do not allow more size~0D~0A    if ($rema
ining <= 0) {~0D~0A        MsgBox("Max position siz
e reached for " + Symbol + ~0D~0A               " (
" + $maxPositionSize + " shares). No additional siz
e allowed.");~0D~0A        return;~0D~0A    }~0D~0A
~0D~0A    // If this clip would exceed max size, cl
amp it down~0D~0A    if ($addShares > $remaining) {
~0D~0A        $addShares = $remaining;~0D~0A    }~0D
~0A~0D~0A}~0D~0A~0D~0A// ---- Tick-size Bands (no f
unctions; simple if-else ladder) ----~0D~0A// We~E2
~80~99ll resolve the increment later using current 
prices.~0D~0A//   < $0.25  -> 0.0005~0D~0A//   < $1
.00  -> 0.001~0D~0A//   ~E2~89~A5 $1.00  -> 0.01~0D
~0A~0D~0A// === 0) Quote sanity & derived prices fo
r safety check ===~0D~0A$bid    = BID;~0D~0A$ask   
 = ASK;~0D~0A$spread = $ask - $bid;~0D~0A~0D~0Aif (
$bid <= 0 || $ask <= 0 || $spread < 0) {~0D~0A    M
sgBox("Quote sanity failed for " + Symbol + ": BID=
" + $bid + " ASK=" + $ask + ". Aborting.");~0D~0A  
  return;~0D~0A}~0D~0A~0D~0A// Projected entry/stop
 based on reference side~0D~0A$pxEntry    = $refPx 
+ $entryOffset;~0D~0A$hypoStop = $pxEntry - $stopLo
ssTrigger;~0D~0A~0D~0A// ---- Resolve tick incremen
t for safety checks (based on current context) ----
~0D~0A$inc = 0.01;~0D~0Aif ($pxEntry < 1 || $hypoSt
op < 1 || $bid < 1 || $ask < 1)        { $inc = 0.0
01; }~0D~0Aif ($pxEntry < 0.25 || $hypoStop < 0.25 
|| $bid < 0.25 || $ask < 0.25) { $inc = 0.0005; }~0D
~0A~0D~0A// === 1) Slippage-aware spread/stop safet
y (longs) ===~0D~0A$stopVsBidFail = 0;~0D~0A~0D~0A/
/ margin for safety = max(slipTicksMin * inc, slipS
preadFrac * spread)~0D~0A$slipMargin         = ($sl
ipTicksMin * $inc);~0D~0A$slipSpreadPart  = ($slipS
preadFrac * $spread);~0D~0Aif ($slipSpreadPart > $s
lipMargin) { $slipMargin = $slipSpreadPart; }~0D~0A
~0D~0Aif ($useSlippageMargin == 1) {~0D~0A    // Re
quire stop to be below (Bid + margin)~0D~0A    if (
$hypoStop >= ($bid + $slipMargin)) { $stopVsBidFail
 = 1; }~0D~0A} else {~0D~0A    if ($hypoStop >= $bi
d) { $stopVsBidFail = 1; }~0D~0A}~0D~0A~0D~0A// spr
ead relative to stop distance guard (tune threshold
 as desired)~0D~0A$spreadTooWide = ($spread > ($sto
pLossTrigger * 0.75)) && $useSpreadCheck == 1;~0D~0A
~0D~0A// If either fails, alert and abort unless we
 are adding to an existing position~0D~0Aif (($stop
VsBidFail == 1 || $spreadTooWide == 1) && $posBefor
e <=0) {~0D~0A    $msg = "Spread/Stop safety failed
 for " + Symbol + "\n" +~0D~0A           "Bid: " + 
$bid + "  Ask: " + $ask + "  Spread: " + $spread + 
"\n" +~0D~0A           "Planned Entry: " + $pxEntry
 + "  Planned Stop: " + $hypoStop + "\n\n";~0D~0A  
  if ($stopVsBidFail == 1)  { $msg = $msg + "- STOP
_ABOVE_BID_WITH_MARGIN\n"; }~0D~0A    if ($spreadTo
oWide == 1)  { $msg = $msg + "- SPREAD_TOO_WIDE vs 
stopOff\n"; }~0D~0A    MsgBox($msg + "\nAction abor
ted.");~0D~0A    return;~0D~0A}~0D~0A~0D~0A// Per-t
rade risk cap (projected risk = stopLossTrigger * a
ddShares)~0D~0Aif ($usePerTradeRiskCap == 1) {~0D~0A
    $projRisk = $stopLossTrigger * $addShares;~0D~0A
    if ($projRisk > $riskCapDollars) {~0D~0A       
 MsgBox("Risk cap exceeded for " + Symbol + ": proj
ected $" + $projRisk + " > cap $" + $riskCapDollars
 + ". Aborting.");~0D~0A        return;~0D~0A    }~0D
~0A}~0D~0A~0D~0A// === 2) Cancel only BUY working o
rders (keep existing protection until we actually f
ill) ===~0D~0A$acc = GetAccountObj(Account);~0D~0A$
acc.CancelOrder("BUY", Symbol, 0);~0D~0A~0D~0A// ==
= 3) Build entry; snap entry to increment to reduce
 rejects ===~0D~0A// Re-evaluate inc using pxEntry 
(some symbols jump bands)~0D~0A$inc = 0.01;~0D~0Aif
 ($pxEntry < 1 || $bid < 1 || $ask < 1) { $inc = 0.
001; }~0D~0Aif ($pxEntry < 0.25 || $bid < 0.25 || $
ask < 0.25) { $inc = 0.0005; }~0D~0A$pxEntry = Roun
d($pxEntry, 102, $inc);~0D~0A~0D~0A$order = NewOrde
rObj();~0D~0A$order.Account = Account;~0D~0A$order.
Symbol  = Symbol;~0D~0A$order.Route   = "ARCA";~0D~0A
$order.Tif     = "DAY+";~0D~0A$order.Side    = "B";
      // Buy~0D~0A$order.Type    = "L";      // Lim
it~0D~0A$order.Price   = $pxEntry;~0D~0A$order.Shar
e   = $addShares;~0D~0A$order.Send();~0D~0A~0D~0A~0D
~0A// === 4) Poll for fill (break when criteria met
) ===~0D~0A$i            = 0;~0D~0A$filled      = 0
;~0D~0A$filledQty = 0;~0D~0Awhile ($i < $maxPolls &
& $filled == 0) {~0D~0A    Wait($pollMs);~0D~0A    
$order.GetInfo();                        // refresh
 order object~0D~0A    $filledQty = $order.Share - 
$order.Open; // how many filled so far~0D~0A    if 
($order.Open == 0) {~0D~0A        $filled = 1; // f
ull fill~0D~0A        break;~0D~0A    }~0D~0A    if
 ($acceptPartial == 1 && $filledQty >= $minFillShar
es) {~0D~0A        $filled = 2; // partial-accepted
~0D~0A        break;~0D~0A    }~0D~0A    $i = $i + 
1;~0D~0A}~0D~0A~0D~0A// throttle between orders~0D~0A
$elapsed = $i * $pollMs;~0D~0Aif ($elapsed < $minDe
layMs) {~0D~0A    Wait($minDelayMs - $elapsed);~0D~0A
}~0D~0A~0D~0A// === 5) If no acceptable fill, cance
l and exit (do not touch existing stops) ===~0D~0Ai
f ($filled == 0) {~0D~0A    $order.Cancel();~0D~0A 
   return;~0D~0A}~0D~0A~0D~0A// Optional: if we acc
epted a partial and want to freeze size before armi
ng stop~0D~0Aif ($filled == 2 && $cancelRemainderOn
Partial == 1) {~0D~0A    $order.Cancel();~0D~0A    
// brief wait to let the residual cancel~0D~0A    W
ait(200);~0D~0A}~0D~0A~0D~0A// === 6) Arm unified 1
R stop via reusable ~E2~80~9CSet Auto Stop~E2~80~9D
 script ===~0D~0Aif ($useAutoStop == "Yes") {~0D~0A
    ExecHotKey("Set Auto Stop");   ~0D~0A}~0D~0A~0D
~0A// == 7) Build and set take profit trigger (opti
onal) ==~0D~0A// Only (re)build TP if we are NOT al
ready profitable on the existing position.~0D~0A// 
For longs, "profitable" means: BID > avgBefore on t
he position that existed~0D~0A// before this entry.
 If we're already green, do NOT reset TP.~0D~0Aif (
$useTakeProfit == "Yes") {~0D~0A~0D~0A    // If no 
position beforehand, always set TP (fresh trade)~0D
~0A    if ($posBefore <= 0) {~0D~0A        ExecHotK
ey("Set Take Profit");~0D~0A    } else {~0D~0A     
   // We had a long position before this add. Check
 profitability.~0D~0A        $bidNow = BID;~0D~0A~0D
~0A        // If avgBefore is invalid, be conservat
ive and allow TP reset~0D~0A        if ($avgBefore 
<= 0) {~0D~0A            ExecHotKey("Set Take Profi
t");~0D~0A        } else {~0D~0A            // Only
 reset TP if NOT yet profitable (bid <= avgBefore)~0D
~0A            if ($bidNow <= $avgBefore) {~0D~0A  
              ExecHotKey("Set Take Profit");~0D~0A 
           }~0D~0A            // else: already prof
itable ~E2~86~92 do nothing, keep existing TP~0D~0A
        }~0D~0A    }~0D~0A}~0D~0A~0D~0A// --- End -
--
Ctrl+Shift+2:Buy 50 Bid+ SL:~ 7452:// =====================~0D~0A//  SCALING-AWARE ENT
RY~0D~0A// =====================~0D~0A~0D~0A// Chec
k rehab flag first~0D~0Aif ($rehab == 1 && $ACCOUNT
_STATE == "live") { MsgBox("ABORTED: Rehabe share s
ize viloation!"); return; }~0D~0A~0D~0AFocusWindow 
Primary_OE;~0D~0A~0D~0A// ---- Global daily-loss gu
ard per account ----~0D~0A$accName = GetVar("DAY_AC
C");~0D~0A$lockKey = "TRADING_LOCKED_" + $accName;~0D
~0A$locked  = GetVar($lockKey) * 1;~0D~0A~0D~0Aif (
$locked == 1) {~0D~0A    MsgBox("Trading locked for
 " + $accName + " (daily loss limit hit).");~0D~0A 
   return;~0D~0A}~0D~0A~0D~0A// Set ENTRY_SYM and c
lear TP_SYMBOL~0D~0A$M = GetWindowObj("Primary_OE")
;~0D~0Aif (IsObj($M)) {~0D~0A    $entrySymbol = $M.
Symb;~0D~0A} else {~0D~0A    $entrySymbol = Symbol;
~0D~0A}~0D~0A$tpSymbol = "";~0D~0A~0D~0A// --- Capt
ure pre-entry position & average cost (for TP logic
) ---~0D~0A$posBefore = 0;~0D~0A$avgBefore = 0;~0D~0A
~0D~0Aif (IsObj($M)) {~0D~0A    $posBefore = $M.Pos
;~0D~0A    $avgBefore = $M.AvgCost;~0D~0A} else {~0D
~0A    $posBefore = Pos;~0D~0A    $avgBefore = AvgC
ost;~0D~0A}~0D~0A~0D~0A// ---- Tunables ----~0D~0A$
addShares     = 50 * $qtyMult;~0D~0A$refPx         
    = BID;             // BID or ASK~0D~0A$minDelay
Ms  = 1000;           // throttle between order sen
ds (ms)~0D~0A~0D~0A// ---- Max position size guard 
rail ----~0D~0Aif ($maxPositionSize > 0) {    ~0D~0A
    // Determine current position in Primary_OE (fa
llback: Pos)~0D~0A    $curPos = 0;~0D~0A    if (IsO
bj($M)) {~0D~0A        $curPos = $M.Pos;~0D~0A    }
 else {~0D~0A        $curPos = Pos;        // DAS b
uilt-in position for current symbol~0D~0A    }~0D~0A
~0D~0A    // Remaining capacity before hitting the 
guard rail~0D~0A    $remaining = $maxPositionSize -
 $curPos;~0D~0A~0D~0A    // If we're already at / a
bove max, do not allow more size~0D~0A    if ($rema
ining <= 0) {~0D~0A        MsgBox("Max position siz
e reached for " + Symbol + ~0D~0A               " (
" + $maxPositionSize + " shares). No additional siz
e allowed.");~0D~0A        return;~0D~0A    }~0D~0A
~0D~0A    // If this clip would exceed max size, cl
amp it down~0D~0A    if ($addShares > $remaining) {
~0D~0A        $addShares = $remaining;~0D~0A    }~0D
~0A~0D~0A}~0D~0A~0D~0A// ---- Tick-size Bands (no f
unctions; simple if-else ladder) ----~0D~0A// We~E2
~80~99ll resolve the increment later using current 
prices.~0D~0A//   < $0.25  -> 0.0005~0D~0A//   < $1
.00  -> 0.001~0D~0A//   ~E2~89~A5 $1.00  -> 0.01~0D
~0A~0D~0A// === 0) Quote sanity & derived prices fo
r safety check ===~0D~0A$bid    = BID;~0D~0A$ask   
 = ASK;~0D~0A$spread = $ask - $bid;~0D~0A~0D~0Aif (
$bid <= 0 || $ask <= 0 || $spread < 0) {~0D~0A    M
sgBox("Quote sanity failed for " + Symbol + ": BID=
" + $bid + " ASK=" + $ask + ". Aborting.");~0D~0A  
  return;~0D~0A}~0D~0A~0D~0A// Projected entry/stop
 based on reference side~0D~0A$pxEntry    = $refPx 
+ $entryOffset;~0D~0A$hypoStop = $pxEntry - $stopLo
ssTrigger;~0D~0A~0D~0A// ---- Resolve tick incremen
t for safety checks (based on current context) ----
~0D~0A$inc = 0.01;~0D~0Aif ($pxEntry < 1 || $hypoSt
op < 1 || $bid < 1 || $ask < 1)        { $inc = 0.0
01; }~0D~0Aif ($pxEntry < 0.25 || $hypoStop < 0.25 
|| $bid < 0.25 || $ask < 0.25) { $inc = 0.0005; }~0D
~0A~0D~0A// === 1) Slippage-aware spread/stop safet
y (longs) ===~0D~0A$stopVsBidFail = 0;~0D~0A~0D~0A/
/ margin for safety = max(slipTicksMin * inc, slipS
preadFrac * spread)~0D~0A$slipMargin         = ($sl
ipTicksMin * $inc);~0D~0A$slipSpreadPart  = ($slipS
preadFrac * $spread);~0D~0Aif ($slipSpreadPart > $s
lipMargin) { $slipMargin = $slipSpreadPart; }~0D~0A
~0D~0Aif ($useSlippageMargin == 1) {~0D~0A    // Re
quire stop to be below (Bid + margin)~0D~0A    if (
$hypoStop >= ($bid + $slipMargin)) { $stopVsBidFail
 = 1; }~0D~0A} else {~0D~0A    if ($hypoStop >= $bi
d) { $stopVsBidFail = 1; }~0D~0A}~0D~0A~0D~0A// spr
ead relative to stop distance guard (tune threshold
 as desired)~0D~0A$spreadTooWide = ($spread > ($sto
pLossTrigger * 0.75)) && $useSpreadCheck == 1;~0D~0A
~0D~0A// If either fails, alert and abort unless we
 are adding to an existing position~0D~0Aif (($stop
VsBidFail == 1 || $spreadTooWide == 1) && $posBefor
e <=0) {~0D~0A    $msg = "Spread/Stop safety failed
 for " + Symbol + "\n" +~0D~0A           "Bid: " + 
$bid + "  Ask: " + $ask + "  Spread: " + $spread + 
"\n" +~0D~0A           "Planned Entry: " + $pxEntry
 + "  Planned Stop: " + $hypoStop + "\n\n";~0D~0A  
  if ($stopVsBidFail == 1)  { $msg = $msg + "- STOP
_ABOVE_BID_WITH_MARGIN\n"; }~0D~0A    if ($spreadTo
oWide == 1)  { $msg = $msg + "- SPREAD_TOO_WIDE vs 
stopOff\n"; }~0D~0A    MsgBox($msg + "\nAction abor
ted.");~0D~0A    return;~0D~0A}~0D~0A~0D~0A// Per-t
rade risk cap (projected risk = stopLossTrigger * a
ddShares)~0D~0Aif ($usePerTradeRiskCap == 1) {~0D~0A
    $projRisk = $stopLossTrigger * $addShares;~0D~0A
    if ($projRisk > $riskCapDollars) {~0D~0A       
 MsgBox("Risk cap exceeded for " + Symbol + ": proj
ected $" + $projRisk + " > cap $" + $riskCapDollars
 + ". Aborting.");~0D~0A        return;~0D~0A    }~0D
~0A}~0D~0A~0D~0A// === 2) Cancel only BUY working o
rders (keep existing protection until we actually f
ill) ===~0D~0A$acc = GetAccountObj(Account);~0D~0A$
acc.CancelOrder("BUY", Symbol, 0);~0D~0A~0D~0A// ==
= 3) Build entry; snap entry to increment to reduce
 rejects ===~0D~0A// Re-evaluate inc using pxEntry 
(some symbols jump bands)~0D~0A$inc = 0.01;~0D~0Aif
 ($pxEntry < 1 || $bid < 1 || $ask < 1) { $inc = 0.
001; }~0D~0Aif ($pxEntry < 0.25 || $bid < 0.25 || $
ask < 0.25) { $inc = 0.0005; }~0D~0A$pxEntry = Roun
d($pxEntry, 102, $inc);~0D~0A~0D~0A$order = NewOrde
rObj();~0D~0A$order.Account = Account;~0D~0A$order.
Symbol  = Symbol;~0D~0A$order.Route   = "ARCA";~0D~0A
$order.Tif     = "DAY+";~0D~0A$order.Side    = "B";
      // Buy~0D~0A$order.Type    = "L";      // Lim
it~0D~0A$order.Price   = $pxEntry;~0D~0A$order.Shar
e   = $addShares;~0D~0A$order.Send();~0D~0A~0D~0A~0D
~0A// === 4) Poll for fill (break when criteria met
) ===~0D~0A$i            = 0;~0D~0A$filled      = 0
;~0D~0A$filledQty = 0;~0D~0Awhile ($i < $maxPolls &
& $filled == 0) {~0D~0A    Wait($pollMs);~0D~0A    
$order.GetInfo();                        // refresh
 order object~0D~0A    $filledQty = $order.Share - 
$order.Open; // how many filled so far~0D~0A    if 
($order.Open == 0) {~0D~0A        $filled = 1; // f
ull fill~0D~0A        break;~0D~0A    }~0D~0A    if
 ($acceptPartial == 1 && $filledQty >= $minFillShar
es) {~0D~0A        $filled = 2; // partial-accepted
~0D~0A        break;~0D~0A    }~0D~0A    $i = $i + 
1;~0D~0A}~0D~0A~0D~0A// throttle between orders~0D~0A
$elapsed = $i * $pollMs;~0D~0Aif ($elapsed < $minDe
layMs) {~0D~0A    Wait($minDelayMs - $elapsed);~0D~0A
}~0D~0A~0D~0A// === 5) If no acceptable fill, cance
l and exit (do not touch existing stops) ===~0D~0Ai
f ($filled == 0) {~0D~0A    $order.Cancel();~0D~0A 
   return;~0D~0A}~0D~0A~0D~0A// Optional: if we acc
epted a partial and want to freeze size before armi
ng stop~0D~0Aif ($filled == 2 && $cancelRemainderOn
Partial == 1) {~0D~0A    $order.Cancel();~0D~0A    
// brief wait to let the residual cancel~0D~0A    W
ait(200);~0D~0A}~0D~0A~0D~0A// === 6) Arm unified 1
R stop via reusable ~E2~80~9CSet Auto Stop~E2~80~9D
 script ===~0D~0Aif ($useAutoStop == "Yes") {~0D~0A
    ExecHotKey("Set Auto Stop");   ~0D~0A}~0D~0A~0D
~0A// == 7) Build and set take profit trigger (opti
onal) ==~0D~0A// Only (re)build TP if we are NOT al
ready profitable on the existing position.~0D~0A// 
For longs, "profitable" means: BID > avgBefore on t
he position that existed~0D~0A// before this entry.
 If we're already green, do NOT reset TP.~0D~0Aif (
$useTakeProfit == "Yes") {~0D~0A~0D~0A    // If no 
position beforehand, always set TP (fresh trade)~0D
~0A    if ($posBefore <= 0) {~0D~0A        ExecHotK
ey("Set Take Profit");~0D~0A    } else {~0D~0A     
   // We had a long position before this add. Check
 profitability.~0D~0A        $bidNow = BID;~0D~0A~0D
~0A        // If avgBefore is invalid, be conservat
ive and allow TP reset~0D~0A        if ($avgBefore 
<= 0) {~0D~0A            ExecHotKey("Set Take Profi
t");~0D~0A        } else {~0D~0A            // Only
 reset TP if NOT yet profitable (bid <= avgBefore)~0D
~0A            if ($bidNow <= $avgBefore) {~0D~0A  
              ExecHotKey("Set Take Profit");~0D~0A 
           }~0D~0A            // else: already prof
itable ~E2~86~92 do nothing, keep existing TP~0D~0A
        }~0D~0A    }~0D~0A}~0D~0A~0D~0A// --- End -
--
Ctrl+Shift+3:Buy 100 Bid+ SL:~ 7451:// =====================~0D~0A//  SCALING-AWARE ENT
RY~0D~0A// =====================~0D~0A~0D~0A// Chec
k rehab flag first~0D~0Aif ($rehab == 1 && $ACCOUNT
_STATE == "live") { MsgBox("ABORTED: Rehabe share s
ize viloation!"); return; }~0D~0AFocusWindow Primar
y_OE;~0D~0A~0D~0A// ---- Global daily-loss guard pe
r account ----~0D~0A$accName = GetVar("DAY_ACC");~0D
~0A$lockKey = "TRADING_LOCKED_" + $accName;~0D~0A$l
ocked  = GetVar($lockKey) * 1;~0D~0A~0D~0Aif ($lock
ed == 1) {~0D~0A    MsgBox("Trading locked for " + 
$accName + " (daily loss limit hit).");~0D~0A    re
turn;~0D~0A}~0D~0A~0D~0A// Set ENTRY_SYM and clear 
TP_SYMBOL~0D~0A$M = GetWindowObj("Primary_OE");~0D~0A
if (IsObj($M)) {~0D~0A    $entrySymbol = $M.Symb;~0D
~0A} else {~0D~0A    $entrySymbol = Symbol;~0D~0A}~0D
~0A$tpSymbol = "";~0D~0A~0D~0A// --- Capture pre-en
try position & average cost (for TP logic) ---~0D~0A
$posBefore = 0;~0D~0A$avgBefore = 0;~0D~0A~0D~0Aif 
(IsObj($M)) {~0D~0A    $posBefore = $M.Pos;~0D~0A  
  $avgBefore = $M.AvgCost;~0D~0A} else {~0D~0A    $
posBefore = Pos;~0D~0A    $avgBefore = AvgCost;~0D~0A
}~0D~0A~0D~0A// ---- Tunables ----~0D~0A$addShares 
    = 100 * $qtyMult;~0D~0A$refPx             = BID
;             // BID or ASK~0D~0A$minDelayMs  = 100
0;           // throttle between order sends (ms)~0D
~0A~0D~0A// ---- Max position size guard rail ----~0D
~0Aif ($maxPositionSize > 0) {    ~0D~0A    // Dete
rmine current position in Primary_OE (fallback: Pos
)~0D~0A    $curPos = 0;~0D~0A    if (IsObj($M)) {~0D
~0A        $curPos = $M.Pos;~0D~0A    } else {~0D~0A
        $curPos = Pos;        // DAS built-in posit
ion for current symbol~0D~0A    }~0D~0A~0D~0A    //
 Remaining capacity before hitting the guard rail~0D
~0A    $remaining = $maxPositionSize - $curPos;~0D~0A
~0D~0A    // If we're already at / above max, do no
t allow more size~0D~0A    if ($remaining <= 0) {~0D
~0A        MsgBox("Max position size reached for " 
+ Symbol + ~0D~0A               " (" + $maxPosition
Size + " shares). No additional size allowed.");~0D
~0A        return;~0D~0A    }~0D~0A~0D~0A    // If 
this clip would exceed max size, clamp it down~0D~0A
    if ($addShares > $remaining) {~0D~0A        $ad
dShares = $remaining;~0D~0A    }~0D~0A~0D~0A}~0D~0A
~0D~0A// ---- Tick-size Bands (no functions; simple
 if-else ladder) ----~0D~0A// We~E2~80~99ll resolve
 the increment later using current prices.~0D~0A// 
  < $0.25  -> 0.0005~0D~0A//   < $1.00  -> 0.001~0D
~0A//   ~E2~89~A5 $1.00  -> 0.01~0D~0A~0D~0A// === 
0) Quote sanity & derived prices for safety check =
==~0D~0A$bid    = BID;~0D~0A$ask    = ASK;~0D~0A$sp
read = $ask - $bid;~0D~0A~0D~0Aif ($bid <= 0 || $as
k <= 0 || $spread < 0) {~0D~0A    MsgBox("Quote san
ity failed for " + Symbol + ": BID=" + $bid + " ASK
=" + $ask + ". Aborting.");~0D~0A    return;~0D~0A}
~0D~0A~0D~0A// Projected entry/stop based on refere
nce side~0D~0A$pxEntry    = $refPx + $entryOffset;~0D
~0A$hypoStop = $pxEntry - $stopLossTrigger;~0D~0A~0D
~0A// ---- Resolve tick increment for safety checks
 (based on current context) ----~0D~0A$inc = 0.01;~0D
~0Aif ($pxEntry < 1 || $hypoStop < 1 || $bid < 1 ||
 $ask < 1)        { $inc = 0.001; }~0D~0Aif ($pxEnt
ry < 0.25 || $hypoStop < 0.25 || $bid < 0.25 || $as
k < 0.25) { $inc = 0.0005; }~0D~0A~0D~0A// === 1) S
lippage-aware spread/stop safety (longs) ===~0D~0A$
stopVsBidFail = 0;~0D~0A~0D~0A// margin for safety 
= max(slipTicksMin * inc, slipSpreadFrac * spread)~0D
~0A$slipMargin         = ($slipTicksMin * $inc);~0D
~0A$slipSpreadPart  = ($slipSpreadFrac * $spread);~0D
~0Aif ($slipSpreadPart > $slipMargin) { $slipMargin
 = $slipSpreadPart; }~0D~0A~0D~0Aif ($useSlippageMa
rgin == 1) {~0D~0A    // Require stop to be below (
Bid + margin)~0D~0A    if ($hypoStop >= ($bid + $sl
ipMargin)) { $stopVsBidFail = 1; }~0D~0A} else {~0D
~0A    if ($hypoStop >= $bid) { $stopVsBidFail = 1;
 }~0D~0A}~0D~0A~0D~0A// spread relative to stop dis
tance guard (tune threshold as desired)~0D~0A$sprea
dTooWide = ($spread > ($stopLossTrigger * 0.75)) &&
 $useSpreadCheck == 1;~0D~0A~0D~0A// If either fail
s, alert and abort unless we are adding to an exist
ing position~0D~0Aif (($stopVsBidFail == 1 || $spre
adTooWide == 1) && $posBefore <=0) {~0D~0A    $msg 
= "Spread/Stop safety failed for " + Symbol + "\n" 
+~0D~0A           "Bid: " + $bid + "  Ask: " + $ask
 + "  Spread: " + $spread + "\n" +~0D~0A           
"Planned Entry: " + $pxEntry + "  Planned Stop: " +
 $hypoStop + "\n\n";~0D~0A    if ($stopVsBidFail ==
 1)  { $msg = $msg + "- STOP_ABOVE_BID_WITH_MARGIN\
n"; }~0D~0A    if ($spreadTooWide == 1)  { $msg = $
msg + "- SPREAD_TOO_WIDE vs stopOff\n"; }~0D~0A    
MsgBox($msg + "\nAction aborted.");~0D~0A    return
;~0D~0A}~0D~0A~0D~0A// Per-trade risk cap (projecte
d risk = stopLossTrigger * addShares)~0D~0Aif ($use
PerTradeRiskCap == 1) {~0D~0A    $projRisk = $stopL
ossTrigger * $addShares;~0D~0A    if ($projRisk > $
riskCapDollars) {~0D~0A        MsgBox("Risk cap exc
eeded for " + Symbol + ": projected $" + $projRisk 
+ " > cap $" + $riskCapDollars + ". Aborting.");~0D
~0A        return;~0D~0A    }~0D~0A}~0D~0A~0D~0A// 
=== 2) Cancel only BUY working orders (keep existin
g protection until we actually fill) ===~0D~0A$acc 
= GetAccountObj(Account);~0D~0A$acc.CancelOrder("BU
Y", Symbol, 0);~0D~0A~0D~0A// === 3) Build entry; s
nap entry to increment to reduce rejects ===~0D~0A/
/ Re-evaluate inc using pxEntry (some symbols jump 
bands)~0D~0A$inc = 0.01;~0D~0Aif ($pxEntry < 1 || $
bid < 1 || $ask < 1) { $inc = 0.001; }~0D~0Aif ($px
Entry < 0.25 || $bid < 0.25 || $ask < 0.25) { $inc 
= 0.0005; }~0D~0A$pxEntry = Round($pxEntry, 102, $i
nc);~0D~0A~0D~0A$order = NewOrderObj();~0D~0A$order
.Account = Account;~0D~0A$order.Symbol  = Symbol;~0D
~0A$order.Route   = "ARCA";~0D~0A$order.Tif     = "
DAY+";~0D~0A$order.Side    = "B";      // Buy~0D~0A
$order.Type    = "L";      // Limit~0D~0A$order.Pri
ce   = $pxEntry;~0D~0A$order.Share   = $addShares;~0D
~0A$order.Send();~0D~0A~0D~0A~0D~0A// === 4) Poll f
or fill (break when criteria met) ===~0D~0A$i      
      = 0;~0D~0A$filled      = 0;~0D~0A$filledQty =
 0;~0D~0Awhile ($i < $maxPolls && $filled == 0) {~0D
~0A    Wait($pollMs);~0D~0A    $order.GetInfo();   
                     // refresh order object~0D~0A 
   $filledQty = $order.Share - $order.Open; // how 
many filled so far~0D~0A    if ($order.Open == 0) {
~0D~0A        $filled = 1; // full fill~0D~0A      
  break;~0D~0A    }~0D~0A    if ($acceptPartial == 
1 && $filledQty >= $minFillShares) {~0D~0A        $
filled = 2; // partial-accepted~0D~0A        break;
~0D~0A    }~0D~0A    $i = $i + 1;~0D~0A}~0D~0A~0D~0A
// throttle between orders~0D~0A$elapsed = $i * $po
llMs;~0D~0Aif ($elapsed < $minDelayMs) {~0D~0A    W
ait($minDelayMs - $elapsed);~0D~0A}~0D~0A~0D~0A// =
== 5) If no acceptable fill, cancel and exit (do no
t touch existing stops) ===~0D~0Aif ($filled == 0) 
{~0D~0A    $order.Cancel();~0D~0A    return;~0D~0A}
~0D~0A~0D~0A// Optional: if we accepted a partial a
nd want to freeze size before arming stop~0D~0Aif (
$filled == 2 && $cancelRemainderOnPartial == 1) {~0D
~0A    $order.Cancel();~0D~0A    // brief wait to l
et the residual cancel~0D~0A    Wait(200);~0D~0A}~0D
~0A~0D~0A// === 6) Arm unified 1R stop via reusable
 ~E2~80~9CSet Auto Stop~E2~80~9D script ===~0D~0Aif
 ($useAutoStop == "Yes") {~0D~0A    ExecHotKey("Set
 Auto Stop");   ~0D~0A}~0D~0A~0D~0A// == 7) Build a
nd set take profit trigger (optional) ==~0D~0A// On
ly (re)build TP if we are NOT already profitable on
 the existing position.~0D~0A// For longs, "profita
ble" means: BID > avgBefore on the position that ex
isted~0D~0A// before this entry. If we're already g
reen, do NOT reset TP.~0D~0Aif ($useTakeProfit == "
Yes") {~0D~0A~0D~0A    // If no position beforehand
, always set TP (fresh trade)~0D~0A    if ($posBefo
re <= 0) {~0D~0A        ExecHotKey("Set Take Profit
");~0D~0A    } else {~0D~0A        // We had a long
 position before this add. Check profitability.~0D~0A
        $bidNow = BID;~0D~0A~0D~0A        // If avg
Before is invalid, be conservative and allow TP res
et~0D~0A        if ($avgBefore <= 0) {~0D~0A       
     ExecHotKey("Set Take Profit");~0D~0A        } 
else {~0D~0A            // Only reset TP if NOT yet
 profitable (bid <= avgBefore)~0D~0A            if 
($bidNow <= $avgBefore) {~0D~0A                Exec
HotKey("Set Take Profit");~0D~0A            }~0D~0A
            // else: already profitable ~E2~86~92 d
o nothing, keep existing TP~0D~0A        }~0D~0A   
 }~0D~0A}~0D~0A~0D~0A// --- End ---
Ctrl+Shift+4:Buy 150 Bid+ SL:~ 7453:// =====================~0D~0A//  SCALING-AWARE ENT
RY~0D~0A// =====================~0D~0A~0D~0A// Chec
k rehab flag first~0D~0Aif ($rehab == 1 && $ACCOUNT
_STATE == "live") { MsgBox("ABORTED: Rehabe share s
ize viloation!"); return; }~0D~0A~0D~0AFocusWindow 
Primary_OE;~0D~0A~0D~0A// ---- Global daily-loss gu
ard per account ----~0D~0A$accName = GetVar("DAY_AC
C");~0D~0A$lockKey = "TRADING_LOCKED_" + $accName;~0D
~0A$locked  = GetVar($lockKey) * 1;~0D~0A~0D~0Aif (
$locked == 1) {~0D~0A    MsgBox("Trading locked for
 " + $accName + " (daily loss limit hit).");~0D~0A 
   return;~0D~0A}~0D~0A~0D~0A// Set ENTRY_SYM and c
lear TP_SYMBOL~0D~0A$M = GetWindowObj("Primary_OE")
;~0D~0Aif (IsObj($M)) {~0D~0A    $entrySymbol = $M.
Symb;~0D~0A} else {~0D~0A    $entrySymbol = Symbol;
~0D~0A}~0D~0A$tpSymbol = "";~0D~0A~0D~0A// --- Capt
ure pre-entry position & average cost (for TP logic
) ---~0D~0A$posBefore = 0;~0D~0A$avgBefore = 0;~0D~0A
~0D~0Aif (IsObj($M)) {~0D~0A    $posBefore = $M.Pos
;~0D~0A    $avgBefore = $M.AvgCost;~0D~0A} else {~0D
~0A    $posBefore = Pos;~0D~0A    $avgBefore = AvgC
ost;~0D~0A}~0D~0A~0D~0A// ---- Tunables ----~0D~0A$
addShares     = 150 * $qtyMult;~0D~0A$refPx        
     = BID;             // BID or ASK~0D~0A$minDela
yMs  = 1000;           // throttle between order se
nds (ms)~0D~0A~0D~0A// ---- Max position size guard
 rail ----~0D~0Aif ($maxPositionSize > 0) {    ~0D~0A
    // Determine current position in Primary_OE (fa
llback: Pos)~0D~0A    $curPos = 0;~0D~0A    if (IsO
bj($M)) {~0D~0A        $curPos = $M.Pos;~0D~0A    }
 else {~0D~0A        $curPos = Pos;        // DAS b
uilt-in position for current symbol~0D~0A    }~0D~0A
~0D~0A    // Remaining capacity before hitting the 
guard rail~0D~0A    $remaining = $maxPositionSize -
 $curPos;~0D~0A~0D~0A    // If we're already at / a
bove max, do not allow more size~0D~0A    if ($rema
ining <= 0) {~0D~0A        MsgBox("Max position siz
e reached for " + Symbol + ~0D~0A               " (
" + $maxPositionSize + " shares). No additional siz
e allowed.");~0D~0A        return;~0D~0A    }~0D~0A
~0D~0A    // If this clip would exceed max size, cl
amp it down~0D~0A    if ($addShares > $remaining) {
~0D~0A        $addShares = $remaining;~0D~0A    }~0D
~0A~0D~0A}~0D~0A~0D~0A// ---- Tick-size Bands (no f
unctions; simple if-else ladder) ----~0D~0A// We~E2
~80~99ll resolve the increment later using current 
prices.~0D~0A//   < $0.25  -> 0.0005~0D~0A//   < $1
.00  -> 0.001~0D~0A//   ~E2~89~A5 $1.00  -> 0.01~0D
~0A~0D~0A// === 0) Quote sanity & derived prices fo
r safety check ===~0D~0A$bid    = BID;~0D~0A$ask   
 = ASK;~0D~0A$spread = $ask - $bid;~0D~0A~0D~0Aif (
$bid <= 0 || $ask <= 0 || $spread < 0) {~0D~0A    M
sgBox("Quote sanity failed for " + Symbol + ": BID=
" + $bid + " ASK=" + $ask + ". Aborting.");~0D~0A  
  return;~0D~0A}~0D~0A~0D~0A// Projected entry/stop
 based on reference side~0D~0A$pxEntry    = $refPx 
+ $entryOffset;~0D~0A$hypoStop = $pxEntry - $stopLo
ssTrigger;~0D~0A~0D~0A// ---- Resolve tick incremen
t for safety checks (based on current context) ----
~0D~0A$inc = 0.01;~0D~0Aif ($pxEntry < 1 || $hypoSt
op < 1 || $bid < 1 || $ask < 1)        { $inc = 0.0
01; }~0D~0Aif ($pxEntry < 0.25 || $hypoStop < 0.25 
|| $bid < 0.25 || $ask < 0.25) { $inc = 0.0005; }~0D
~0A~0D~0A// === 1) Slippage-aware spread/stop safet
y (longs) ===~0D~0A$stopVsBidFail = 0;~0D~0A~0D~0A/
/ margin for safety = max(slipTicksMin * inc, slipS
preadFrac * spread)~0D~0A$slipMargin         = ($sl
ipTicksMin * $inc);~0D~0A$slipSpreadPart  = ($slipS
preadFrac * $spread);~0D~0Aif ($slipSpreadPart > $s
lipMargin) { $slipMargin = $slipSpreadPart; }~0D~0A
~0D~0Aif ($useSlippageMargin == 1) {~0D~0A    // Re
quire stop to be below (Bid + margin)~0D~0A    if (
$hypoStop >= ($bid + $slipMargin)) { $stopVsBidFail
 = 1; }~0D~0A} else {~0D~0A    if ($hypoStop >= $bi
d) { $stopVsBidFail = 1; }~0D~0A}~0D~0A~0D~0A// spr
ead relative to stop distance guard (tune threshold
 as desired)~0D~0A$spreadTooWide = ($spread > ($sto
pLossTrigger * 0.75)) && $useSpreadCheck == 1;~0D~0A
~0D~0A// If either fails, alert and abort unless we
 are adding to an existing position~0D~0Aif (($stop
VsBidFail == 1 || $spreadTooWide == 1) && $posBefor
e <=0) {~0D~0A    $msg = "Spread/Stop safety failed
 for " + Symbol + "\n" +~0D~0A           "Bid: " + 
$bid + "  Ask: " + $ask + "  Spread: " + $spread + 
"\n" +~0D~0A           "Planned Entry: " + $pxEntry
 + "  Planned Stop: " + $hypoStop + "\n\n";~0D~0A  
  if ($stopVsBidFail == 1)  { $msg = $msg + "- STOP
_ABOVE_BID_WITH_MARGIN\n"; }~0D~0A    if ($spreadTo
oWide == 1)  { $msg = $msg + "- SPREAD_TOO_WIDE vs 
stopOff\n"; }~0D~0A    MsgBox($msg + "\nAction abor
ted.");~0D~0A    return;~0D~0A}~0D~0A~0D~0A// Per-t
rade risk cap (projected risk = stopLossTrigger * a
ddShares)~0D~0Aif ($usePerTradeRiskCap == 1) {~0D~0A
    $projRisk = $stopLossTrigger * $addShares;~0D~0A
    if ($projRisk > $riskCapDollars) {~0D~0A       
 MsgBox("Risk cap exceeded for " + Symbol + ": proj
ected $" + $projRisk + " > cap $" + $riskCapDollars
 + ". Aborting.");~0D~0A        return;~0D~0A    }~0D
~0A}~0D~0A~0D~0A// === 2) Cancel only BUY working o
rders (keep existing protection until we actually f
ill) ===~0D~0A$acc = GetAccountObj(Account);~0D~0A$
acc.CancelOrder("BUY", Symbol, 0);~0D~0A~0D~0A// ==
= 3) Build entry; snap entry to increment to reduce
 rejects ===~0D~0A// Re-evaluate inc using pxEntry 
(some symbols jump bands)~0D~0A$inc = 0.01;~0D~0Aif
 ($pxEntry < 1 || $bid < 1 || $ask < 1) { $inc = 0.
001; }~0D~0Aif ($pxEntry < 0.25 || $bid < 0.25 || $
ask < 0.25) { $inc = 0.0005; }~0D~0A$pxEntry = Roun
d($pxEntry, 102, $inc);~0D~0A~0D~0A$order = NewOrde
rObj();~0D~0A$order.Account = Account;~0D~0A$order.
Symbol  = Symbol;~0D~0A$order.Route   = "ARCA";~0D~0A
$order.Tif     = "DAY+";~0D~0A$order.Side    = "B";
      // Buy~0D~0A$order.Type    = "L";      // Lim
it~0D~0A$order.Price   = $pxEntry;~0D~0A$order.Shar
e   = $addShares;~0D~0A$order.Send();~0D~0A~0D~0A~0D
~0A// === 4) Poll for fill (break when criteria met
) ===~0D~0A$i            = 0;~0D~0A$filled      = 0
;~0D~0A$filledQty = 0;~0D~0Awhile ($i < $maxPolls &
& $filled == 0) {~0D~0A    Wait($pollMs);~0D~0A    
$order.GetInfo();                        // refresh
 order object~0D~0A    $filledQty = $order.Share - 
$order.Open; // how many filled so far~0D~0A    if 
($order.Open == 0) {~0D~0A        $filled = 1; // f
ull fill~0D~0A        break;~0D~0A    }~0D~0A    if
 ($acceptPartial == 1 && $filledQty >= $minFillShar
es) {~0D~0A        $filled = 2; // partial-accepted
~0D~0A        break;~0D~0A    }~0D~0A    $i = $i + 
1;~0D~0A}~0D~0A~0D~0A// throttle between orders~0D~0A
$elapsed = $i * $pollMs;~0D~0Aif ($elapsed < $minDe
layMs) {~0D~0A    Wait($minDelayMs - $elapsed);~0D~0A
}~0D~0A~0D~0A// === 5) If no acceptable fill, cance
l and exit (do not touch existing stops) ===~0D~0Ai
f ($filled == 0) {~0D~0A    $order.Cancel();~0D~0A 
   return;~0D~0A}~0D~0A~0D~0A// Optional: if we acc
epted a partial and want to freeze size before armi
ng stop~0D~0Aif ($filled == 2 && $cancelRemainderOn
Partial == 1) {~0D~0A    $order.Cancel();~0D~0A    
// brief wait to let the residual cancel~0D~0A    W
ait(200);~0D~0A}~0D~0A~0D~0A// === 6) Arm unified 1
R stop via reusable ~E2~80~9CSet Auto Stop~E2~80~9D
 script ===~0D~0Aif ($useAutoStop == "Yes") {~0D~0A
    ExecHotKey("Set Auto Stop");   ~0D~0A}~0D~0A~0D
~0A// == 7) Build and set take profit trigger (opti
onal) ==~0D~0A// Only (re)build TP if we are NOT al
ready profitable on the existing position.~0D~0A// 
For longs, "profitable" means: BID > avgBefore on t
he position that existed~0D~0A// before this entry.
 If we're already green, do NOT reset TP.~0D~0Aif (
$useTakeProfit == "Yes") {~0D~0A~0D~0A    // If no 
position beforehand, always set TP (fresh trade)~0D
~0A    if ($posBefore <= 0) {~0D~0A        ExecHotK
ey("Set Take Profit");~0D~0A    } else {~0D~0A     
   // We had a long position before this add. Check
 profitability.~0D~0A        $bidNow = BID;~0D~0A~0D
~0A        // If avgBefore is invalid, be conservat
ive and allow TP reset~0D~0A        if ($avgBefore 
<= 0) {~0D~0A            ExecHotKey("Set Take Profi
t");~0D~0A        } else {~0D~0A            // Only
 reset TP if NOT yet profitable (bid <= avgBefore)~0D
~0A            if ($bidNow <= $avgBefore) {~0D~0A  
              ExecHotKey("Set Take Profit");~0D~0A 
           }~0D~0A            // else: already prof
itable ~E2~86~92 do nothing, keep existing TP~0D~0A
        }~0D~0A    }~0D~0A}~0D~0A~0D~0A// --- End -
--
Alt+Ctrl+1:Buy 10 Bid SL:~ 7535:// =====================~0D~0A//  SCALING-AWARE ENT
RY~0D~0A// =====================~0D~0A~0D~0AFocusWi
ndow Primary_OE;~0D~0A~0D~0A// ---- Global daily-lo
ss guard per account ----~0D~0A$accName = GetVar("D
AY_ACC");~0D~0A$lockKey = "TRADING_LOCKED_" + $accN
ame;~0D~0A$locked  = GetVar($lockKey) * 1;~0D~0A~0D
~0Aif ($locked == 1) {~0D~0A    MsgBox("Trading loc
ked for " + $accName + " (daily loss limit hit).");
~0D~0A    return;~0D~0A}~0D~0A~0D~0A// Set ENTRY_SY
M and clear TP_SYMBOL~0D~0A$M = GetWindowObj("Prima
ry_OE");~0D~0Aif (IsObj($M)) {~0D~0A    $entrySymbo
l = $M.Symb;~0D~0A} else {~0D~0A    $entrySymbol = 
Symbol;~0D~0A}~0D~0A$tpSymbol = "";~0D~0A~0D~0A// -
-- Capture pre-entry position & average cost (for T
P logic) ---~0D~0A$posBefore = 0;~0D~0A$avgBefore =
 0;~0D~0A~0D~0Aif (IsObj($M)) {~0D~0A    $posBefore
 = $M.Pos;~0D~0A    $avgBefore = $M.AvgCost;~0D~0A}
 else {~0D~0A    $posBefore = Pos;~0D~0A    $avgBef
ore = AvgCost;~0D~0A}~0D~0A~0D~0Aif ($rehab ==1 && 
$M.Pos > 0) {~0D~0A    MsgBox("ABORTED: Rehab size 
violation, scaling in not allowed!");~0D~0A    retu
rn;~0D~0A}~0D~0A~0D~0A// Ice Breaker = 1/4 of norma
l share size~0D~0A$quarter = 50 * $qtyMult * 0.25;~0D
~0A$scaled = $quarter + 2.5;~0D~0A$addShares = $sca
led - ($scaled % 5);~0D~0A~0D~0A// ---- Tunables --
--~0D~0A$refPx             = BID;             // BI
D or ASK~0D~0A$minDelayMs  = 1000;           // thr
ottle between order sends (ms)~0D~0A~0D~0A// ---- M
ax position size guard rail ----~0D~0Aif ($maxPosit
ionSize > 0) {    ~0D~0A    // Determine current po
sition in Primary_OE (fallback: Pos)~0D~0A    $curP
os = 0;~0D~0A    if (IsObj($M)) {~0D~0A        $cur
Pos = $M.Pos;~0D~0A    } else {~0D~0A        $curPo
s = Pos;        // DAS built-in position for curren
t symbol~0D~0A    }~0D~0A~0D~0A    // Remaining cap
acity before hitting the guard rail~0D~0A    $remai
ning = $maxPositionSize - $curPos;~0D~0A~0D~0A    /
/ If we're already at / above max, do not allow mor
e size~0D~0A    if ($remaining <= 0) {~0D~0A       
 MsgBox("Max position size reached for " + Symbol +
 ~0D~0A               " (" + $maxPositionSize + " s
hares). No additional size allowed.");~0D~0A       
 return;~0D~0A    }~0D~0A~0D~0A    // If this clip 
would exceed max size, clamp it down~0D~0A    if ($
addShares > $remaining) {~0D~0A        $addShares =
 $remaining;~0D~0A    }~0D~0A~0D~0A}~0D~0A~0D~0A// 
---- Tick-size Bands (no functions; simple if-else 
ladder) ----~0D~0A// We~E2~80~99ll resolve the incr
ement later using current prices.~0D~0A//   < $0.25
  -> 0.0005~0D~0A//   < $1.00  -> 0.001~0D~0A//   ~E2
~89~A5 $1.00  -> 0.01~0D~0A~0D~0A// === 0) Quote sa
nity & derived prices for safety check ===~0D~0A$bi
d    = BID;~0D~0A$ask    = ASK;~0D~0A$spread = $ask
 - $bid;~0D~0A~0D~0Aif ($bid <= 0 || $ask <= 0 || $
spread < 0) {~0D~0A    MsgBox("Quote sanity failed 
for " + Symbol + ": BID=" + $bid + " ASK=" + $ask +
 ". Aborting.");~0D~0A    return;~0D~0A}~0D~0A~0D~0A
// Projected entry/stop based on reference side~0D~0A
$pxEntry    = $refPx;~0D~0A$hypoStop = $pxEntry - $
stopLossTrigger;~0D~0A~0D~0A// ---- Resolve tick in
crement for safety checks (based on current context
) ----~0D~0A$inc = 0.01;~0D~0Aif ($pxEntry < 1 || $
hypoStop < 1 || $bid < 1 || $ask < 1)        { $inc
 = 0.001; }~0D~0Aif ($pxEntry < 0.25 || $hypoStop <
 0.25 || $bid < 0.25 || $ask < 0.25) { $inc = 0.000
5; }~0D~0A~0D~0A// === 1) Slippage-aware spread/sto
p safety (longs) ===~0D~0A$stopVsBidFail = 0;~0D~0A
~0D~0A// margin for safety = max(slipTicksMin * inc
, slipSpreadFrac * spread)~0D~0A$slipMargin        
 = ($slipTicksMin * $inc);~0D~0A$slipSpreadPart  = 
($slipSpreadFrac * $spread);~0D~0Aif ($slipSpreadPa
rt > $slipMargin) { $slipMargin = $slipSpreadPart; 
}~0D~0A~0D~0Aif ($useSlippageMargin == 1) {~0D~0A  
  // Require stop to be below (Bid + margin)~0D~0A 
   if ($hypoStop >= ($bid + $slipMargin)) { $stopVs
BidFail = 1; }~0D~0A} else {~0D~0A    if ($hypoStop
 >= $bid) { $stopVsBidFail = 1; }~0D~0A}~0D~0A~0D~0A
// spread relative to stop distance guard (tune thr
eshold as desired)~0D~0A$spreadTooWide = ($spread >
 ($stopLossTrigger * 0.75)) && $useSpreadCheck == 1
;~0D~0A~0D~0A// If either fails, alert and abort un
less we are adding to an existing position~0D~0Aif 
(($stopVsBidFail == 1 || $spreadTooWide == 1) && $p
osBefore <=0) {~0D~0A    $msg = "Spread/Stop safety
 failed for " + Symbol + "\n" +~0D~0A           "Bi
d: " + $bid + "  Ask: " + $ask + "  Spread: " + $sp
read + "\n" +~0D~0A           "Planned Entry: " + $
pxEntry + "  Planned Stop: " + $hypoStop + "\n\n";~0D
~0A    if ($stopVsBidFail == 1)  { $msg = $msg + "-
 STOP_ABOVE_BID_WITH_MARGIN\n"; }~0D~0A    if ($spr
eadTooWide == 1)  { $msg = $msg + "- SPREAD_TOO_WID
E vs stopOff\n"; }~0D~0A    MsgBox($msg + "\nAction
 aborted.");~0D~0A    return;~0D~0A}~0D~0A~0D~0A// 
Per-trade risk cap (projected risk = stopLossTrigge
r * addShares)~0D~0Aif ($usePerTradeRiskCap == 1) {
~0D~0A    $projRisk = $stopLossTrigger * $addShares
;~0D~0A    if ($projRisk > $riskCapDollars) {~0D~0A
        MsgBox("Risk cap exceeded for " + Symbol + 
": projected $" + $projRisk + " > cap $" + $riskCap
Dollars + ". Aborting.");~0D~0A        return;~0D~0A
    }~0D~0A}~0D~0A~0D~0A// === 2) Cancel only BUY w
orking orders (keep existing protection until we ac
tually fill) ===~0D~0A$acc = GetAccountObj(Account)
;~0D~0A$acc.CancelOrder("BUY", Symbol, 0);~0D~0A~0D
~0A// === 3) Build entry; snap entry to increment t
o reduce rejects ===~0D~0A// Re-evaluate inc using 
pxEntry (some symbols jump bands)~0D~0A$inc = 0.01;
~0D~0Aif ($pxEntry < 1 || $bid < 1 || $ask < 1) { $
inc = 0.001; }~0D~0Aif ($pxEntry < 0.25 || $bid < 0
.25 || $ask < 0.25) { $inc = 0.0005; }~0D~0A$pxEntr
y = Round($pxEntry, 102, $inc);~0D~0A~0D~0A$order =
 NewOrderObj();~0D~0A$order.Account = Account;~0D~0A
$order.Symbol  = Symbol;~0D~0A$order.Route   = "ARC
A";~0D~0A$order.Tif     = "DAY+";~0D~0A$order.Side 
   = "B";      // Buy~0D~0A$order.Type    = "L";   
   // Limit~0D~0A$order.Price   = $pxEntry;~0D~0A$o
rder.Share   = $addShares;~0D~0A$order.Send();~0D~0A
~0D~0A~0D~0A// === 4) Poll for fill (break when cri
teria met) ===~0D~0A$i            = 0;~0D~0A$filled
      = 0;~0D~0A$filledQty = 0;~0D~0Awhile ($i < $m
axPolls && $filled == 0) {~0D~0A    Wait($pollMs);~0D
~0A    $order.GetInfo();                        // 
refresh order object~0D~0A    $filledQty = $order.S
hare - $order.Open; // how many filled so far~0D~0A
    if ($order.Open == 0) {~0D~0A        $filled = 
1; // full fill~0D~0A        break;~0D~0A    }~0D~0A
    if ($acceptPartial == 1 && $filledQty >= $minFi
llShares) {~0D~0A        $filled = 2; // partial-ac
cepted~0D~0A        break;~0D~0A    }~0D~0A    $i =
 $i + 1;~0D~0A}~0D~0A~0D~0A// throttle between orde
rs~0D~0A$elapsed = $i * $pollMs;~0D~0Aif ($elapsed 
< $minDelayMs) {~0D~0A    Wait($minDelayMs - $elaps
ed);~0D~0A}~0D~0A~0D~0A// === 5) If no acceptable f
ill, cancel and exit (do not touch existing stops) 
===~0D~0Aif ($filled == 0) {~0D~0A    $order.Cancel
();~0D~0A    return;~0D~0A}~0D~0A~0D~0A// Optional:
 if we accepted a partial and want to freeze size b
efore arming stop~0D~0Aif ($filled == 2 && $cancelR
emainderOnPartial == 1) {~0D~0A    $order.Cancel();
~0D~0A    // brief wait to let the residual cancel~0D
~0A    Wait(200);~0D~0A}~0D~0A~0D~0A// === 6) Arm u
nified 1R stop via reusable ~E2~80~9CSet Auto Stop~E2
~80~9D script ===~0D~0Aif ($useAutoStop == "Yes") {
~0D~0A    ExecHotKey("Set Auto Stop");   ~0D~0A}~0D
~0A~0D~0A// == 7) Build and set take profit trigger
 (optional) ==~0D~0A// Only (re)build TP if we are 
NOT already profitable on the existing position.~0D
~0A// For longs, "profitable" means: BID > avgBefor
e on the position that existed~0D~0A// before this 
entry. If we're already green, do NOT reset TP.~0D~0A
if ($useTakeProfit == "Yes") {~0D~0A~0D~0A    // If
 no position beforehand, always set TP (fresh trade
)~0D~0A    if ($posBefore <= 0) {~0D~0A        Exec
HotKey("Set Take Profit");~0D~0A    } else {~0D~0A 
       // We had a long position before this add. C
heck profitability.~0D~0A        $bidNow = BID;~0D~0A
~0D~0A        // If avgBefore is invalid, be conser
vative and allow TP reset~0D~0A        if ($avgBefo
re <= 0) {~0D~0A            ExecHotKey("Set Take Pr
ofit");~0D~0A        } else {~0D~0A            // O
nly reset TP if NOT yet profitable (bid <= avgBefor
e)~0D~0A            if ($bidNow <= $avgBefore) {~0D
~0A                ExecHotKey("Set Take Profit");~0D
~0A            }~0D~0A            // else: already 
profitable ~E2~86~92 do nothing, keep existing TP~0D
~0A        }~0D~0A    }~0D~0A}~0D~0A~0D~0A// --- En
d ---
Alt+Ctrl+2:Buy 50 Bid SL:~ 7437:// =====================~0D~0A//  SCALING-AWARE ENT
RY~0D~0A// =====================~0D~0A~0D~0A// Chec
k rehab flag first~0D~0Aif ($rehab == 1 && $ACCOUNT
_STATE == "live") { MsgBox("ABORTED: Rehabe share s
ize viloation!"); return; }~0D~0A~0D~0AFocusWindow 
Primary_OE;~0D~0A~0D~0A// ---- Global daily-loss gu
ard per account ----~0D~0A$accName = GetVar("DAY_AC
C");~0D~0A$lockKey = "TRADING_LOCKED_" + $accName;~0D
~0A$locked  = GetVar($lockKey) * 1;~0D~0A~0D~0Aif (
$locked == 1) {~0D~0A    MsgBox("Trading locked for
 " + $accName + " (daily loss limit hit).");~0D~0A 
   return;~0D~0A}~0D~0A~0D~0A// Set ENTRY_SYM and c
lear TP_SYMBOL~0D~0A$M = GetWindowObj("Primary_OE")
;~0D~0Aif (IsObj($M)) {~0D~0A    $entrySymbol = $M.
Symb;~0D~0A} else {~0D~0A    $entrySymbol = Symbol;
~0D~0A}~0D~0A$tpSymbol = "";~0D~0A~0D~0A// --- Capt
ure pre-entry position & average cost (for TP logic
) ---~0D~0A$posBefore = 0;~0D~0A$avgBefore = 0;~0D~0A
~0D~0Aif (IsObj($M)) {~0D~0A    $posBefore = $M.Pos
;~0D~0A    $avgBefore = $M.AvgCost;~0D~0A} else {~0D
~0A    $posBefore = Pos;~0D~0A    $avgBefore = AvgC
ost;~0D~0A}~0D~0A~0D~0A// ---- Tunables ----~0D~0A$
addShares     = 50 * $qtyMult;~0D~0A$refPx         
    = BID;             // BID or ASK~0D~0A$minDelay
Ms  = 1000;           // throttle between order sen
ds (ms)~0D~0A~0D~0A// ---- Max position size guard 
rail ----~0D~0Aif ($maxPositionSize > 0) {    ~0D~0A
    // Determine current position in Primary_OE (fa
llback: Pos)~0D~0A    $curPos = 0;~0D~0A    if (IsO
bj($M)) {~0D~0A        $curPos = $M.Pos;~0D~0A    }
 else {~0D~0A        $curPos = Pos;        // DAS b
uilt-in position for current symbol~0D~0A    }~0D~0A
~0D~0A    // Remaining capacity before hitting the 
guard rail~0D~0A    $remaining = $maxPositionSize -
 $curPos;~0D~0A~0D~0A    // If we're already at / a
bove max, do not allow more size~0D~0A    if ($rema
ining <= 0) {~0D~0A        MsgBox("Max position siz
e reached for " + Symbol + ~0D~0A               " (
" + $maxPositionSize + " shares). No additional siz
e allowed.");~0D~0A        return;~0D~0A    }~0D~0A
~0D~0A    // If this clip would exceed max size, cl
amp it down~0D~0A    if ($addShares > $remaining) {
~0D~0A        $addShares = $remaining;~0D~0A    }~0D
~0A~0D~0A}~0D~0A~0D~0A// ---- Tick-size Bands (no f
unctions; simple if-else ladder) ----~0D~0A// We~E2
~80~99ll resolve the increment later using current 
prices.~0D~0A//   < $0.25  -> 0.0005~0D~0A//   < $1
.00  -> 0.001~0D~0A//   ~E2~89~A5 $1.00  -> 0.01~0D
~0A~0D~0A// === 0) Quote sanity & derived prices fo
r safety check ===~0D~0A$bid    = BID;~0D~0A$ask   
 = ASK;~0D~0A$spread = $ask - $bid;~0D~0A~0D~0Aif (
$bid <= 0 || $ask <= 0 || $spread < 0) {~0D~0A    M
sgBox("Quote sanity failed for " + Symbol + ": BID=
" + $bid + " ASK=" + $ask + ". Aborting.");~0D~0A  
  return;~0D~0A}~0D~0A~0D~0A// Projected entry/stop
 based on reference side~0D~0A$pxEntry    = $refPx;
~0D~0A$hypoStop = $pxEntry - $stopLossTrigger;~0D~0A
~0D~0A// ---- Resolve tick increment for safety che
cks (based on current context) ----~0D~0A$inc = 0.0
1;~0D~0Aif ($pxEntry < 1 || $hypoStop < 1 || $bid <
 1 || $ask < 1)        { $inc = 0.001; }~0D~0Aif ($
pxEntry < 0.25 || $hypoStop < 0.25 || $bid < 0.25 |
| $ask < 0.25) { $inc = 0.0005; }~0D~0A~0D~0A// ===
 1) Slippage-aware spread/stop safety (longs) ===~0D
~0A$stopVsBidFail = 0;~0D~0A~0D~0A// margin for saf
ety = max(slipTicksMin * inc, slipSpreadFrac * spre
ad)~0D~0A$slipMargin         = ($slipTicksMin * $in
c);~0D~0A$slipSpreadPart  = ($slipSpreadFrac * $spr
ead);~0D~0Aif ($slipSpreadPart > $slipMargin) { $sl
ipMargin = $slipSpreadPart; }~0D~0A~0D~0Aif ($useSl
ippageMargin == 1) {~0D~0A    // Require stop to be
 below (Bid + margin)~0D~0A    if ($hypoStop >= ($b
id + $slipMargin)) { $stopVsBidFail = 1; }~0D~0A} e
lse {~0D~0A    if ($hypoStop >= $bid) { $stopVsBidF
ail = 1; }~0D~0A}~0D~0A~0D~0A// spread relative to 
stop distance guard (tune threshold as desired)~0D~0A
$spreadTooWide = ($spread > ($stopLossTrigger * 0.7
5)) && $useSpreadCheck == 1;~0D~0A~0D~0A// If eithe
r fails, alert and abort unless we are adding to an
 existing position~0D~0Aif (($stopVsBidFail == 1 ||
 $spreadTooWide == 1) && $posBefore <=0) {~0D~0A   
 $msg = "Spread/Stop safety failed for " + Symbol +
 "\n" +~0D~0A           "Bid: " + $bid + "  Ask: " 
+ $ask + "  Spread: " + $spread + "\n" +~0D~0A     
      "Planned Entry: " + $pxEntry + "  Planned Sto
p: " + $hypoStop + "\n\n";~0D~0A    if ($stopVsBidF
ail == 1)  { $msg = $msg + "- STOP_ABOVE_BID_WITH_M
ARGIN\n"; }~0D~0A    if ($spreadTooWide == 1)  { $m
sg = $msg + "- SPREAD_TOO_WIDE vs stopOff\n"; }~0D~0A
    MsgBox($msg + "\nAction aborted.");~0D~0A    re
turn;~0D~0A}~0D~0A~0D~0A// Per-trade risk cap (proj
ected risk = stopLossTrigger * addShares)~0D~0Aif (
$usePerTradeRiskCap == 1) {~0D~0A    $projRisk = $s
topLossTrigger * $addShares;~0D~0A    if ($projRisk
 > $riskCapDollars) {~0D~0A        MsgBox("Risk cap
 exceeded for " + Symbol + ": projected $" + $projR
isk + " > cap $" + $riskCapDollars + ". Aborting.")
;~0D~0A        return;~0D~0A    }~0D~0A}~0D~0A~0D~0A
// === 2) Cancel only BUY working orders (keep exis
ting protection until we actually fill) ===~0D~0A$a
cc = GetAccountObj(Account);~0D~0A$acc.CancelOrder(
"BUY", Symbol, 0);~0D~0A~0D~0A// === 3) Build entry
; snap entry to increment to reduce rejects ===~0D~0A
// Re-evaluate inc using pxEntry (some symbols jump
 bands)~0D~0A$inc = 0.01;~0D~0Aif ($pxEntry < 1 || 
$bid < 1 || $ask < 1) { $inc = 0.001; }~0D~0Aif ($p
xEntry < 0.25 || $bid < 0.25 || $ask < 0.25) { $inc
 = 0.0005; }~0D~0A$pxEntry = Round($pxEntry, 102, $
inc);~0D~0A~0D~0A$order = NewOrderObj();~0D~0A$orde
r.Account = Account;~0D~0A$order.Symbol  = Symbol;~0D
~0A$order.Route   = "ARCA";~0D~0A$order.Tif     = "
DAY+";~0D~0A$order.Side    = "B";      // Buy~0D~0A
$order.Type    = "L";      // Limit~0D~0A$order.Pri
ce   = $pxEntry;~0D~0A$order.Share   = $addShares;~0D
~0A$order.Send();~0D~0A~0D~0A~0D~0A// === 4) Poll f
or fill (break when criteria met) ===~0D~0A$i      
      = 0;~0D~0A$filled      = 0;~0D~0A$filledQty =
 0;~0D~0Awhile ($i < $maxPolls && $filled == 0) {~0D
~0A    Wait($pollMs);~0D~0A    $order.GetInfo();   
                     // refresh order object~0D~0A 
   $filledQty = $order.Share - $order.Open; // how 
many filled so far~0D~0A    if ($order.Open == 0) {
~0D~0A        $filled = 1; // full fill~0D~0A      
  break;~0D~0A    }~0D~0A    if ($acceptPartial == 
1 && $filledQty >= $minFillShares) {~0D~0A        $
filled = 2; // partial-accepted~0D~0A        break;
~0D~0A    }~0D~0A    $i = $i + 1;~0D~0A}~0D~0A~0D~0A
// throttle between orders~0D~0A$elapsed = $i * $po
llMs;~0D~0Aif ($elapsed < $minDelayMs) {~0D~0A    W
ait($minDelayMs - $elapsed);~0D~0A}~0D~0A~0D~0A// =
== 5) If no acceptable fill, cancel and exit (do no
t touch existing stops) ===~0D~0Aif ($filled == 0) 
{~0D~0A    $order.Cancel();~0D~0A    return;~0D~0A}
~0D~0A~0D~0A// Optional: if we accepted a partial a
nd want to freeze size before arming stop~0D~0Aif (
$filled == 2 && $cancelRemainderOnPartial == 1) {~0D
~0A    $order.Cancel();~0D~0A    // brief wait to l
et the residual cancel~0D~0A    Wait(200);~0D~0A}~0D
~0A~0D~0A// === 6) Arm unified 1R stop via reusable
 ~E2~80~9CSet Auto Stop~E2~80~9D script ===~0D~0Aif
 ($useAutoStop == "Yes") {~0D~0A    ExecHotKey("Set
 Auto Stop");   ~0D~0A}~0D~0A~0D~0A// == 7) Build a
nd set take profit trigger (optional) ==~0D~0A// On
ly (re)build TP if we are NOT already profitable on
 the existing position.~0D~0A// For longs, "profita
ble" means: BID > avgBefore on the position that ex
isted~0D~0A// before this entry. If we're already g
reen, do NOT reset TP.~0D~0Aif ($useTakeProfit == "
Yes") {~0D~0A~0D~0A    // If no position beforehand
, always set TP (fresh trade)~0D~0A    if ($posBefo
re <= 0) {~0D~0A        ExecHotKey("Set Take Profit
");~0D~0A    } else {~0D~0A        // We had a long
 position before this add. Check profitability.~0D~0A
        $bidNow = BID;~0D~0A~0D~0A        // If avg
Before is invalid, be conservative and allow TP res
et~0D~0A        if ($avgBefore <= 0) {~0D~0A       
     ExecHotKey("Set Take Profit");~0D~0A        } 
else {~0D~0A            // Only reset TP if NOT yet
 profitable (bid <= avgBefore)~0D~0A            if 
($bidNow <= $avgBefore) {~0D~0A                Exec
HotKey("Set Take Profit");~0D~0A            }~0D~0A
            // else: already profitable ~E2~86~92 d
o nothing, keep existing TP~0D~0A        }~0D~0A   
 }~0D~0A}~0D~0A~0D~0A// --- End ---
Alt+Ctrl+3:Buy 100 Bid SL:~ 7438:// =====================~0D~0A//  SCALING-AWARE ENT
RY~0D~0A// =====================~0D~0A~0D~0A// Chec
k rehab flag first~0D~0Aif ($rehab == 1 && $ACCOUNT
_STATE == "live") { MsgBox("ABORTED: Rehabe share s
ize viloation!"); return; }~0D~0A~0D~0AFocusWindow 
Primary_OE;~0D~0A~0D~0A// ---- Global daily-loss gu
ard per account ----~0D~0A$accName = GetVar("DAY_AC
C");~0D~0A$lockKey = "TRADING_LOCKED_" + $accName;~0D
~0A$locked  = GetVar($lockKey) * 1;~0D~0A~0D~0Aif (
$locked == 1) {~0D~0A    MsgBox("Trading locked for
 " + $accName + " (daily loss limit hit).");~0D~0A 
   return;~0D~0A}~0D~0A~0D~0A// Set ENTRY_SYM and c
lear TP_SYMBOL~0D~0A$M = GetWindowObj("Primary_OE")
;~0D~0Aif (IsObj($M)) {~0D~0A    $entrySymbol = $M.
Symb;~0D~0A} else {~0D~0A    $entrySymbol = Symbol;
~0D~0A}~0D~0A$tpSymbol = "";~0D~0A~0D~0A// --- Capt
ure pre-entry position & average cost (for TP logic
) ---~0D~0A$posBefore = 0;~0D~0A$avgBefore = 0;~0D~0A
~0D~0Aif (IsObj($M)) {~0D~0A    $posBefore = $M.Pos
;~0D~0A    $avgBefore = $M.AvgCost;~0D~0A} else {~0D
~0A    $posBefore = Pos;~0D~0A    $avgBefore = AvgC
ost;~0D~0A}~0D~0A~0D~0A// ---- Tunables ----~0D~0A$
addShares     = 100 * $qtyMult;~0D~0A$refPx        
     = BID;             // BID or ASK~0D~0A$minDela
yMs  = 1000;           // throttle between order se
nds (ms)~0D~0A~0D~0A// ---- Max position size guard
 rail ----~0D~0Aif ($maxPositionSize > 0) {    ~0D~0A
    // Determine current position in Primary_OE (fa
llback: Pos)~0D~0A    $curPos = 0;~0D~0A    if (IsO
bj($M)) {~0D~0A        $curPos = $M.Pos;~0D~0A    }
 else {~0D~0A        $curPos = Pos;        // DAS b
uilt-in position for current symbol~0D~0A    }~0D~0A
~0D~0A    // Remaining capacity before hitting the 
guard rail~0D~0A    $remaining = $maxPositionSize -
 $curPos;~0D~0A~0D~0A    // If we're already at / a
bove max, do not allow more size~0D~0A    if ($rema
ining <= 0) {~0D~0A        MsgBox("Max position siz
e reached for " + Symbol + ~0D~0A               " (
" + $maxPositionSize + " shares). No additional siz
e allowed.");~0D~0A        return;~0D~0A    }~0D~0A
~0D~0A    // If this clip would exceed max size, cl
amp it down~0D~0A    if ($addShares > $remaining) {
~0D~0A        $addShares = $remaining;~0D~0A    }~0D
~0A~0D~0A}~0D~0A~0D~0A// ---- Tick-size Bands (no f
unctions; simple if-else ladder) ----~0D~0A// We~E2
~80~99ll resolve the increment later using current 
prices.~0D~0A//   < $0.25  -> 0.0005~0D~0A//   < $1
.00  -> 0.001~0D~0A//   ~E2~89~A5 $1.00  -> 0.01~0D
~0A~0D~0A// === 0) Quote sanity & derived prices fo
r safety check ===~0D~0A$bid    = BID;~0D~0A$ask   
 = ASK;~0D~0A$spread = $ask - $bid;~0D~0A~0D~0Aif (
$bid <= 0 || $ask <= 0 || $spread < 0) {~0D~0A    M
sgBox("Quote sanity failed for " + Symbol + ": BID=
" + $bid + " ASK=" + $ask + ". Aborting.");~0D~0A  
  return;~0D~0A}~0D~0A~0D~0A// Projected entry/stop
 based on reference side~0D~0A$pxEntry    = $refPx;
~0D~0A$hypoStop = $pxEntry - $stopLossTrigger;~0D~0A
~0D~0A// ---- Resolve tick increment for safety che
cks (based on current context) ----~0D~0A$inc = 0.0
1;~0D~0Aif ($pxEntry < 1 || $hypoStop < 1 || $bid <
 1 || $ask < 1)        { $inc = 0.001; }~0D~0Aif ($
pxEntry < 0.25 || $hypoStop < 0.25 || $bid < 0.25 |
| $ask < 0.25) { $inc = 0.0005; }~0D~0A~0D~0A// ===
 1) Slippage-aware spread/stop safety (longs) ===~0D
~0A$stopVsBidFail = 0;~0D~0A~0D~0A// margin for saf
ety = max(slipTicksMin * inc, slipSpreadFrac * spre
ad)~0D~0A$slipMargin         = ($slipTicksMin * $in
c);~0D~0A$slipSpreadPart  = ($slipSpreadFrac * $spr
ead);~0D~0Aif ($slipSpreadPart > $slipMargin) { $sl
ipMargin = $slipSpreadPart; }~0D~0A~0D~0Aif ($useSl
ippageMargin == 1) {~0D~0A    // Require stop to be
 below (Bid + margin)~0D~0A    if ($hypoStop >= ($b
id + $slipMargin)) { $stopVsBidFail = 1; }~0D~0A} e
lse {~0D~0A    if ($hypoStop >= $bid) { $stopVsBidF
ail = 1; }~0D~0A}~0D~0A~0D~0A// spread relative to 
stop distance guard (tune threshold as desired)~0D~0A
$spreadTooWide = ($spread > ($stopLossTrigger * 0.7
5)) && $useSpreadCheck == 1;~0D~0A~0D~0A// If eithe
r fails, alert and abort unless we are adding to an
 existing position~0D~0Aif (($stopVsBidFail == 1 ||
 $spreadTooWide == 1) && $posBefore <=0) {~0D~0A   
 $msg = "Spread/Stop safety failed for " + Symbol +
 "\n" +~0D~0A           "Bid: " + $bid + "  Ask: " 
+ $ask + "  Spread: " + $spread + "\n" +~0D~0A     
      "Planned Entry: " + $pxEntry + "  Planned Sto
p: " + $hypoStop + "\n\n";~0D~0A    if ($stopVsBidF
ail == 1)  { $msg = $msg + "- STOP_ABOVE_BID_WITH_M
ARGIN\n"; }~0D~0A    if ($spreadTooWide == 1)  { $m
sg = $msg + "- SPREAD_TOO_WIDE vs stopOff\n"; }~0D~0A
    MsgBox($msg + "\nAction aborted.");~0D~0A    re
turn;~0D~0A}~0D~0A~0D~0A// Per-trade risk cap (proj
ected risk = stopLossTrigger * addShares)~0D~0Aif (
$usePerTradeRiskCap == 1) {~0D~0A    $projRisk = $s
topLossTrigger * $addShares;~0D~0A    if ($projRisk
 > $riskCapDollars) {~0D~0A        MsgBox("Risk cap
 exceeded for " + Symbol + ": projected $" + $projR
isk + " > cap $" + $riskCapDollars + ". Aborting.")
;~0D~0A        return;~0D~0A    }~0D~0A}~0D~0A~0D~0A
// === 2) Cancel only BUY working orders (keep exis
ting protection until we actually fill) ===~0D~0A$a
cc = GetAccountObj(Account);~0D~0A$acc.CancelOrder(
"BUY", Symbol, 0);~0D~0A~0D~0A// === 3) Build entry
; snap entry to increment to reduce rejects ===~0D~0A
// Re-evaluate inc using pxEntry (some symbols jump
 bands)~0D~0A$inc = 0.01;~0D~0Aif ($pxEntry < 1 || 
$bid < 1 || $ask < 1) { $inc = 0.001; }~0D~0Aif ($p
xEntry < 0.25 || $bid < 0.25 || $ask < 0.25) { $inc
 = 0.0005; }~0D~0A$pxEntry = Round($pxEntry, 102, $
inc);~0D~0A~0D~0A$order = NewOrderObj();~0D~0A$orde
r.Account = Account;~0D~0A$order.Symbol  = Symbol;~0D
~0A$order.Route   = "ARCA";~0D~0A$order.Tif     = "
DAY+";~0D~0A$order.Side    = "B";      // Buy~0D~0A
$order.Type    = "L";      // Limit~0D~0A$order.Pri
ce   = $pxEntry;~0D~0A$order.Share   = $addShares;~0D
~0A$order.Send();~0D~0A~0D~0A~0D~0A// === 4) Poll f
or fill (break when criteria met) ===~0D~0A$i      
      = 0;~0D~0A$filled      = 0;~0D~0A$filledQty =
 0;~0D~0Awhile ($i < $maxPolls && $filled == 0) {~0D
~0A    Wait($pollMs);~0D~0A    $order.GetInfo();   
                     // refresh order object~0D~0A 
   $filledQty = $order.Share - $order.Open; // how 
many filled so far~0D~0A    if ($order.Open == 0) {
~0D~0A        $filled = 1; // full fill~0D~0A      
  break;~0D~0A    }~0D~0A    if ($acceptPartial == 
1 && $filledQty >= $minFillShares) {~0D~0A        $
filled = 2; // partial-accepted~0D~0A        break;
~0D~0A    }~0D~0A    $i = $i + 1;~0D~0A}~0D~0A~0D~0A
// throttle between orders~0D~0A$elapsed = $i * $po
llMs;~0D~0Aif ($elapsed < $minDelayMs) {~0D~0A    W
ait($minDelayMs - $elapsed);~0D~0A}~0D~0A~0D~0A// =
== 5) If no acceptable fill, cancel and exit (do no
t touch existing stops) ===~0D~0Aif ($filled == 0) 
{~0D~0A    $order.Cancel();~0D~0A    return;~0D~0A}
~0D~0A~0D~0A// Optional: if we accepted a partial a
nd want to freeze size before arming stop~0D~0Aif (
$filled == 2 && $cancelRemainderOnPartial == 1) {~0D
~0A    $order.Cancel();~0D~0A    // brief wait to l
et the residual cancel~0D~0A    Wait(200);~0D~0A}~0D
~0A~0D~0A// === 6) Arm unified 1R stop via reusable
 ~E2~80~9CSet Auto Stop~E2~80~9D script ===~0D~0Aif
 ($useAutoStop == "Yes") {~0D~0A    ExecHotKey("Set
 Auto Stop");   ~0D~0A}~0D~0A~0D~0A// == 7) Build a
nd set take profit trigger (optional) ==~0D~0A// On
ly (re)build TP if we are NOT already profitable on
 the existing position.~0D~0A// For longs, "profita
ble" means: BID > avgBefore on the position that ex
isted~0D~0A// before this entry. If we're already g
reen, do NOT reset TP.~0D~0Aif ($useTakeProfit == "
Yes") {~0D~0A~0D~0A    // If no position beforehand
, always set TP (fresh trade)~0D~0A    if ($posBefo
re <= 0) {~0D~0A        ExecHotKey("Set Take Profit
");~0D~0A    } else {~0D~0A        // We had a long
 position before this add. Check profitability.~0D~0A
        $bidNow = BID;~0D~0A~0D~0A        // If avg
Before is invalid, be conservative and allow TP res
et~0D~0A        if ($avgBefore <= 0) {~0D~0A       
     ExecHotKey("Set Take Profit");~0D~0A        } 
else {~0D~0A            // Only reset TP if NOT yet
 profitable (bid <= avgBefore)~0D~0A            if 
($bidNow <= $avgBefore) {~0D~0A                Exec
HotKey("Set Take Profit");~0D~0A            }~0D~0A
            // else: already profitable ~E2~86~92 d
o nothing, keep existing TP~0D~0A        }~0D~0A   
 }~0D~0A}~0D~0A~0D~0A// --- End ---
Alt+Ctrl+4:Buy 150 Bid SL:~ 7438:// =====================~0D~0A//  SCALING-AWARE ENT
RY~0D~0A// =====================~0D~0A~0D~0A// Chec
k rehab flag first~0D~0Aif ($rehab == 1 && $ACCOUNT
_STATE == "live") { MsgBox("ABORTED: Rehabe share s
ize viloation!"); return; }~0D~0A~0D~0AFocusWindow 
Primary_OE;~0D~0A~0D~0A// ---- Global daily-loss gu
ard per account ----~0D~0A$accName = GetVar("DAY_AC
C");~0D~0A$lockKey = "TRADING_LOCKED_" + $accName;~0D
~0A$locked  = GetVar($lockKey) * 1;~0D~0A~0D~0Aif (
$locked == 1) {~0D~0A    MsgBox("Trading locked for
 " + $accName + " (daily loss limit hit).");~0D~0A 
   return;~0D~0A}~0D~0A~0D~0A// Set ENTRY_SYM and c
lear TP_SYMBOL~0D~0A$M = GetWindowObj("Primary_OE")
;~0D~0Aif (IsObj($M)) {~0D~0A    $entrySymbol = $M.
Symb;~0D~0A} else {~0D~0A    $entrySymbol = Symbol;
~0D~0A}~0D~0A$tpSymbol = "";~0D~0A~0D~0A// --- Capt
ure pre-entry position & average cost (for TP logic
) ---~0D~0A$posBefore = 0;~0D~0A$avgBefore = 0;~0D~0A
~0D~0Aif (IsObj($M)) {~0D~0A    $posBefore = $M.Pos
;~0D~0A    $avgBefore = $M.AvgCost;~0D~0A} else {~0D
~0A    $posBefore = Pos;~0D~0A    $avgBefore = AvgC
ost;~0D~0A}~0D~0A~0D~0A// ---- Tunables ----~0D~0A$
addShares     = 150 * $qtyMult;~0D~0A$refPx        
     = BID;             // BID or ASK~0D~0A$minDela
yMs  = 1000;           // throttle between order se
nds (ms)~0D~0A~0D~0A// ---- Max position size guard
 rail ----~0D~0Aif ($maxPositionSize > 0) {    ~0D~0A
    // Determine current position in Primary_OE (fa
llback: Pos)~0D~0A    $curPos = 0;~0D~0A    if (IsO
bj($M)) {~0D~0A        $curPos = $M.Pos;~0D~0A    }
 else {~0D~0A        $curPos = Pos;        // DAS b
uilt-in position for current symbol~0D~0A    }~0D~0A
~0D~0A    // Remaining capacity before hitting the 
guard rail~0D~0A    $remaining = $maxPositionSize -
 $curPos;~0D~0A~0D~0A    // If we're already at / a
bove max, do not allow more size~0D~0A    if ($rema
ining <= 0) {~0D~0A        MsgBox("Max position siz
e reached for " + Symbol + ~0D~0A               " (
" + $maxPositionSize + " shares). No additional siz
e allowed.");~0D~0A        return;~0D~0A    }~0D~0A
~0D~0A    // If this clip would exceed max size, cl
amp it down~0D~0A    if ($addShares > $remaining) {
~0D~0A        $addShares = $remaining;~0D~0A    }~0D
~0A~0D~0A}~0D~0A~0D~0A// ---- Tick-size Bands (no f
unctions; simple if-else ladder) ----~0D~0A// We~E2
~80~99ll resolve the increment later using current 
prices.~0D~0A//   < $0.25  -> 0.0005~0D~0A//   < $1
.00  -> 0.001~0D~0A//   ~E2~89~A5 $1.00  -> 0.01~0D
~0A~0D~0A// === 0) Quote sanity & derived prices fo
r safety check ===~0D~0A$bid    = BID;~0D~0A$ask   
 = ASK;~0D~0A$spread = $ask - $bid;~0D~0A~0D~0Aif (
$bid <= 0 || $ask <= 0 || $spread < 0) {~0D~0A    M
sgBox("Quote sanity failed for " + Symbol + ": BID=
" + $bid + " ASK=" + $ask + ". Aborting.");~0D~0A  
  return;~0D~0A}~0D~0A~0D~0A// Projected entry/stop
 based on reference side~0D~0A$pxEntry    = $refPx;
~0D~0A$hypoStop = $pxEntry - $stopLossTrigger;~0D~0A
~0D~0A// ---- Resolve tick increment for safety che
cks (based on current context) ----~0D~0A$inc = 0.0
1;~0D~0Aif ($pxEntry < 1 || $hypoStop < 1 || $bid <
 1 || $ask < 1)        { $inc = 0.001; }~0D~0Aif ($
pxEntry < 0.25 || $hypoStop < 0.25 || $bid < 0.25 |
| $ask < 0.25) { $inc = 0.0005; }~0D~0A~0D~0A// ===
 1) Slippage-aware spread/stop safety (longs) ===~0D
~0A$stopVsBidFail = 0;~0D~0A~0D~0A// margin for saf
ety = max(slipTicksMin * inc, slipSpreadFrac * spre
ad)~0D~0A$slipMargin         = ($slipTicksMin * $in
c);~0D~0A$slipSpreadPart  = ($slipSpreadFrac * $spr
ead);~0D~0Aif ($slipSpreadPart > $slipMargin) { $sl
ipMargin = $slipSpreadPart; }~0D~0A~0D~0Aif ($useSl
ippageMargin == 1) {~0D~0A    // Require stop to be
 below (Bid + margin)~0D~0A    if ($hypoStop >= ($b
id + $slipMargin)) { $stopVsBidFail = 1; }~0D~0A} e
lse {~0D~0A    if ($hypoStop >= $bid) { $stopVsBidF
ail = 1; }~0D~0A}~0D~0A~0D~0A// spread relative to 
stop distance guard (tune threshold as desired)~0D~0A
$spreadTooWide = ($spread > ($stopLossTrigger * 0.7
5)) && $useSpreadCheck == 1;~0D~0A~0D~0A// If eithe
r fails, alert and abort unless we are adding to an
 existing position~0D~0Aif (($stopVsBidFail == 1 ||
 $spreadTooWide == 1) && $posBefore <=0) {~0D~0A   
 $msg = "Spread/Stop safety failed for " + Symbol +
 "\n" +~0D~0A           "Bid: " + $bid + "  Ask: " 
+ $ask + "  Spread: " + $spread + "\n" +~0D~0A     
      "Planned Entry: " + $pxEntry + "  Planned Sto
p: " + $hypoStop + "\n\n";~0D~0A    if ($stopVsBidF
ail == 1)  { $msg = $msg + "- STOP_ABOVE_BID_WITH_M
ARGIN\n"; }~0D~0A    if ($spreadTooWide == 1)  { $m
sg = $msg + "- SPREAD_TOO_WIDE vs stopOff\n"; }~0D~0A
    MsgBox($msg + "\nAction aborted.");~0D~0A    re
turn;~0D~0A}~0D~0A~0D~0A// Per-trade risk cap (proj
ected risk = stopLossTrigger * addShares)~0D~0Aif (
$usePerTradeRiskCap == 1) {~0D~0A    $projRisk = $s
topLossTrigger * $addShares;~0D~0A    if ($projRisk
 > $riskCapDollars) {~0D~0A        MsgBox("Risk cap
 exceeded for " + Symbol + ": projected $" + $projR
isk + " > cap $" + $riskCapDollars + ". Aborting.")
;~0D~0A        return;~0D~0A    }~0D~0A}~0D~0A~0D~0A
// === 2) Cancel only BUY working orders (keep exis
ting protection until we actually fill) ===~0D~0A$a
cc = GetAccountObj(Account);~0D~0A$acc.CancelOrder(
"BUY", Symbol, 0);~0D~0A~0D~0A// === 3) Build entry
; snap entry to increment to reduce rejects ===~0D~0A
// Re-evaluate inc using pxEntry (some symbols jump
 bands)~0D~0A$inc = 0.01;~0D~0Aif ($pxEntry < 1 || 
$bid < 1 || $ask < 1) { $inc = 0.001; }~0D~0Aif ($p
xEntry < 0.25 || $bid < 0.25 || $ask < 0.25) { $inc
 = 0.0005; }~0D~0A$pxEntry = Round($pxEntry, 102, $
inc);~0D~0A~0D~0A$order = NewOrderObj();~0D~0A$orde
r.Account = Account;~0D~0A$order.Symbol  = Symbol;~0D
~0A$order.Route   = "ARCA";~0D~0A$order.Tif     = "
DAY+";~0D~0A$order.Side    = "B";      // Buy~0D~0A
$order.Type    = "L";      // Limit~0D~0A$order.Pri
ce   = $pxEntry;~0D~0A$order.Share   = $addShares;~0D
~0A$order.Send();~0D~0A~0D~0A~0D~0A// === 4) Poll f
or fill (break when criteria met) ===~0D~0A$i      
      = 0;~0D~0A$filled      = 0;~0D~0A$filledQty =
 0;~0D~0Awhile ($i < $maxPolls && $filled == 0) {~0D
~0A    Wait($pollMs);~0D~0A    $order.GetInfo();   
                     // refresh order object~0D~0A 
   $filledQty = $order.Share - $order.Open; // how 
many filled so far~0D~0A    if ($order.Open == 0) {
~0D~0A        $filled = 1; // full fill~0D~0A      
  break;~0D~0A    }~0D~0A    if ($acceptPartial == 
1 && $filledQty >= $minFillShares) {~0D~0A        $
filled = 2; // partial-accepted~0D~0A        break;
~0D~0A    }~0D~0A    $i = $i + 1;~0D~0A}~0D~0A~0D~0A
// throttle between orders~0D~0A$elapsed = $i * $po
llMs;~0D~0Aif ($elapsed < $minDelayMs) {~0D~0A    W
ait($minDelayMs - $elapsed);~0D~0A}~0D~0A~0D~0A// =
== 5) If no acceptable fill, cancel and exit (do no
t touch existing stops) ===~0D~0Aif ($filled == 0) 
{~0D~0A    $order.Cancel();~0D~0A    return;~0D~0A}
~0D~0A~0D~0A// Optional: if we accepted a partial a
nd want to freeze size before arming stop~0D~0Aif (
$filled == 2 && $cancelRemainderOnPartial == 1) {~0D
~0A    $order.Cancel();~0D~0A    // brief wait to l
et the residual cancel~0D~0A    Wait(200);~0D~0A}~0D
~0A~0D~0A// === 6) Arm unified 1R stop via reusable
 ~E2~80~9CSet Auto Stop~E2~80~9D script ===~0D~0Aif
 ($useAutoStop == "Yes") {~0D~0A    ExecHotKey("Set
 Auto Stop");   ~0D~0A}~0D~0A~0D~0A// == 7) Build a
nd set take profit trigger (optional) ==~0D~0A// On
ly (re)build TP if we are NOT already profitable on
 the existing position.~0D~0A// For longs, "profita
ble" means: BID > avgBefore on the position that ex
isted~0D~0A// before this entry. If we're already g
reen, do NOT reset TP.~0D~0Aif ($useTakeProfit == "
Yes") {~0D~0A~0D~0A    // If no position beforehand
, always set TP (fresh trade)~0D~0A    if ($posBefo
re <= 0) {~0D~0A        ExecHotKey("Set Take Profit
");~0D~0A    } else {~0D~0A        // We had a long
 position before this add. Check profitability.~0D~0A
        $bidNow = BID;~0D~0A~0D~0A        // If avg
Before is invalid, be conservative and allow TP res
et~0D~0A        if ($avgBefore <= 0) {~0D~0A       
     ExecHotKey("Set Take Profit");~0D~0A        } 
else {~0D~0A            // Only reset TP if NOT yet
 profitable (bid <= avgBefore)~0D~0A            if 
($bidNow <= $avgBefore) {~0D~0A                Exec
HotKey("Set Take Profit");~0D~0A            }~0D~0A
            // else: already profitable ~E2~86~92 d
o nothing, keep existing TP~0D~0A        }~0D~0A   
 }~0D~0A}~0D~0A~0D~0A// --- End ---
Ctrl+Shift+S:Set Auto Stop:~ 4405:// =====================~0D~0A//  SET AUTO STOP (1R
, LONG ONLY)~0D~0A// =====================~0D~0A//~0D
~0A// Reusable stop-loss engine~0D~0A// - Uses STOP
LOSS_TRIGGER global (1R in dollars)~0D~0A// - Uses 
ENTRY_REF_PX (optional) as fallback if AvgCost is l
agging~0D~0A// - Honors USE_AUTO_STOP global~0D~0A/
/ - Uses Primary_OE montage object (no global Symbo
l/Account dependency)~0D~0A// - Places a unified SL
P stop for current symbol/account~0D~0A//~0D~0A~0D~0A
FocusWindow Primary_OE;~0D~0A~0D~0A// 1) Get Primar
y_OE montage object~0D~0A$M = GetWindowObj("Primary
_OE");~0D~0Aif (!IsObj($M)) {~0D~0A    MsgBox("Set 
Auto Stop: montage 'Primary_OE' not found. Aborting
.");~0D~0A    return;~0D~0A}~0D~0A~0D~0A// Pull con
text from montage object~0D~0A$myAcc  = $M.Account;
~0D~0A$mySym  = $M.Symb;~0D~0A$posNow = $M.Pos;~0D~0A
$avgNow = $M.AvgCost;~0D~0A~0D~0A// LONG-ONLY: if n
o long position, nothing to protect~0D~0Aif ($posNo
w <= 0) {~0D~0A    return;~0D~0A}~0D~0A~0D~0A// Try
 to let AvgCost populate if it's lagging~0D~0A$j = 
0;~0D~0Awhile ($posNow > 0 && $avgNow <= 0 && $j < 
10) {~0D~0A    Wait(50);~0D~0A    $avgNow = $M.AvgC
ost;~0D~0A    $j = $j + 1;~0D~0A}~0D~0A~0D~0A// Sea
tbelt: if still no AvgCost but we do have size, anc
hor to entry ref if available~0D~0Aif ($posNow > 0 
&& $avgNow <= 0) {~0D~0A    if ($entryRefPx > 0) {~0D
~0A        $avgNow = $entryRefPx;~0D~0A    } else {
~0D~0A        $avgNow = $M.Last;   // last fallback
 from montage~0D~0A    }~0D~0A}~0D~0A~0D~0Aif ($pos
Now <= 0 || $avgNow <= 0) {~0D~0A    // something i
s very off; abort rather than arm bad stop~0D~0A   
 return;~0D~0A}~0D~0A~0D~0A// 2) Tunables specific 
to STOP behavior~0D~0A// TODO~0D~0A$useAdaptiveLimi
tOff  = 1;     // 1=offset based on spread; 0=use f
ixed $limitOff~0D~0A$adapt_k              = 2.0;   
// limit offset = max(minTicks*inc, min(maxLimitOff
, k*spread))~0D~0A$adapt_minTicks       = 2;     //
 min ticks for stop-limit offset~0D~0A$adapt_maxLim
itOff    = 0.25;  // hard cap in dollars on limit o
ffset~0D~0A$verifyStopPosted     = 1;     // 1=read
 back stop and verify; retry once; then fallback to
 SL~0D~0A~0D~0A// 3) Cancel existing SELL-side work
ing orders~0D~0A$accObj = GetAccountObj($myAcc);~0D
~0A$accObj.CancelOrder("SELL", $mySym, 0);~0D~0A~0D
~0A// Let cancels register; avoid races~0D~0AWait(3
50);~0D~0A~0D~0A// 4) Compute raw 1R stop~0D~0A$sto
p = $avgNow - $stopLossTrigger;~0D~0A~0D~0A// 5) Re
solve tick-size bands for stop/limit and snapping~0D
~0A$inc = 0.01;~0D~0Aif ($avgNow < 1 || $stop < 1) 
       { $inc = 0.001; }~0D~0Aif ($avgNow < 0.25 ||
 $stop < 0.25)  { $inc = 0.0005; }~0D~0A~0D~0A$stop
 = Round($stop, 102, $inc);~0D~0A~0D~0A// 6) Adapti
ve stop-limit offset~0D~0A$effLimitOff = $exitOffse
t;~0D~0Aif ($useAdaptiveLimitOff == 1) {~0D~0A    /
/ Use montage-level quotes, not globals~0D~0A    $s
preadNow   = $M.Ask - $M.Bid;~0D~0A    $effLimitOff
 = ($adapt_k * $spreadNow);~0D~0A    // floor to mi
n ticks~0D~0A    $minOff = ($adapt_minTicks * $inc)
;~0D~0A    if ($effLimitOff < $minOff)            {
 $effLimitOff = $minOff; }~0D~0A    // cap~0D~0A   
 if ($effLimitOff > $adapt_maxLimitOff) { $effLimit
Off = $adapt_maxLimitOff; }~0D~0A}~0D~0A~0D~0A// Co
mpute and snap limit~0D~0A$px = $stop - $effLimitOf
f;~0D~0A$px = Round($px, 102, $inc);~0D~0A~0D~0A// 
Safety: ensure SLP limit is strictly below trigger 
(for sells)~0D~0Aif ($px >= $stop) {~0D~0A    $px =
 Round($stop - $inc, 102, $inc);~0D~0A}~0D~0A~0D~0A
// 7) Build & send unified SLP stop~0D~0A$qtyProtec
t = Round($posNow, 0);~0D~0Aif ($qtyProtect <= 0) {
~0D~0A    return;~0D~0A}~0D~0A~0D~0A$s = NewOrderOb
j();~0D~0A$s.Account    = $myAcc;~0D~0A$s.Symbol   
  = $mySym;~0D~0A$s.Route       = "STOP";~0D~0A$s.T
if            = "DAY+";~0D~0A$s.Side         = "S";
~0D~0A$s.Type         = "SLP";        // Stop-Limit
 (P)~0D~0A$s.StopPrice = $stop;~0D~0A$s.Price      
  = $px;~0D~0A$s.Share       = $qtyProtect;  // pro
tect entire current position~0D~0A$s.Send();~0D~0A~0D
~0A// small settle to register~0D~0AWait(200);~0D~0A
~0D~0A// 8) Verify stop posted (optional)~0D~0Aif (
$verifyStopPosted == 1) {~0D~0A    $s.GetInfo();   
// refresh object if supported~0D~0A    $ok = 1;~0D
~0A~0D~0A    if ($s.StopPrice != $stop)      { $ok 
= 0; }~0D~0A    if ($s.Price     != $px)        { $
ok = 0; }~0D~0A    if ($s.Share     != $qtyProtect)
{ $ok = 0; }~0D~0A~0D~0A    if ($ok == 0) {~0D~0A  
      // retry once after a brief backoff~0D~0A    
    Wait(300);~0D~0A        $s.Send();~0D~0A       
 Wait(200);~0D~0A        $s.GetInfo();~0D~0A~0D~0A 
       $ok = 1;~0D~0A        if ($s.StopPrice != $s
top)      { $ok = 0; }~0D~0A        if ($s.Price   
  != $px)        { $ok = 0; }~0D~0A        if ($s.S
hare     != $qtyProtect){ $ok = 0; }~0D~0A~0D~0A   
     // If still not OK, fallback to plain SL~0D~0A
        if ($ok == 0) {~0D~0A            $s.Type = 
"SL";~0D~0A            $s.Send();~0D~0A            
MsgBox("Set Auto Stop: verification failed for " + 
$mySym + ". Fallback SL sent.");~0D~0A        }~0D~0A
    }~0D~0A}~0D~0A~0D~0A// --- End Set Auto Stop --
-
Alt+Shift+1:Buy 10 Ask SL:~ 7563:// =====================~0D~0A//  SCALING-AWARE ENT
RY~0D~0A// =====================~0D~0A~0D~0AFocusWi
ndow Primary_OE;~0D~0A~0D~0A// ---- Global daily-lo
ss guard per account ----~0D~0A$accName = GetVar("D
AY_ACC");~0D~0A$lockKey = "TRADING_LOCKED_" + $accN
ame;~0D~0A$locked  = GetVar($lockKey) * 1;~0D~0A~0D
~0Aif ($locked == 1) {~0D~0A    MsgBox("Trading loc
ked for " + $accName + " (daily loss limit hit).");
~0D~0A    return;~0D~0A}~0D~0A~0D~0A// Set ENTRY_SY
M and clear TP_SYMBOL~0D~0A$M = GetWindowObj("Prima
ry_OE");~0D~0Aif (IsObj($M)) {~0D~0A    $entrySymbo
l = $M.Symb;~0D~0A} else {~0D~0A    $entrySymbol = 
Symbol;~0D~0A}~0D~0A$tpSymbol = "";~0D~0A~0D~0A// -
-- Capture pre-entry position & average cost (for T
P logic) ---~0D~0A$posBefore = 0;~0D~0A$avgBefore =
 0;~0D~0A~0D~0Aif (IsObj($M)) {~0D~0A    $posBefore
 = $M.Pos;~0D~0A    $avgBefore = $M.AvgCost;~0D~0A}
 else {~0D~0A    $posBefore = Pos;~0D~0A    $avgBef
ore = AvgCost;~0D~0A}~0D~0A~0D~0Aif ($rehab ==1 && 
$M.Pos > 0 && $ACCOUNT_STATE == "live") {~0D~0A    
MsgBox("ABORTED: Rehab size violation, scaling in n
ot allowed!");~0D~0A    return;~0D~0A}~0D~0A~0D~0A/
/ Ice Breaker = 1/4 of normal share size~0D~0A$quar
ter = 50 * $qtyMult * 0.25;~0D~0A$scaled = $quarter
 + 2.5;~0D~0A$addShares = $scaled - ($scaled % 5);~0D
~0A~0D~0A// ---- Tunables ----~0D~0A$refPx         
    = ASK;             // BID or ASK~0D~0A$minDelay
Ms  = 1000;           // throttle between order sen
ds (ms)~0D~0A~0D~0A// ---- Max position size guard 
rail ----~0D~0Aif ($maxPositionSize > 0) {    ~0D~0A
    // Determine current position in Primary_OE (fa
llback: Pos)~0D~0A    $curPos = 0;~0D~0A    if (IsO
bj($M)) {~0D~0A        $curPos = $M.Pos;~0D~0A    }
 else {~0D~0A        $curPos = Pos;        // DAS b
uilt-in position for current symbol~0D~0A    }~0D~0A
~0D~0A    // Remaining capacity before hitting the 
guard rail~0D~0A    $remaining = $maxPositionSize -
 $curPos;~0D~0A~0D~0A    // If we're already at / a
bove max, do not allow more size~0D~0A    if ($rema
ining <= 0) {~0D~0A        MsgBox("Max position siz
e reached for " + Symbol + ~0D~0A               " (
" + $maxPositionSize + " shares). No additional siz
e allowed.");~0D~0A        return;~0D~0A    }~0D~0A
~0D~0A    // If this clip would exceed max size, cl
amp it down~0D~0A    if ($addShares > $remaining) {
~0D~0A        $addShares = $remaining;~0D~0A    }~0D
~0A~0D~0A}~0D~0A~0D~0A// ---- Tick-size Bands (no f
unctions; simple if-else ladder) ----~0D~0A// We~E2
~80~99ll resolve the increment later using current 
prices.~0D~0A//   < $0.25  -> 0.0005~0D~0A//   < $1
.00  -> 0.001~0D~0A//   ~E2~89~A5 $1.00  -> 0.01~0D
~0A~0D~0A// === 0) Quote sanity & derived prices fo
r safety check ===~0D~0A$bid    = BID;~0D~0A$ask   
 = ASK;~0D~0A$spread = $ask - $bid;~0D~0A~0D~0Aif (
$bid <= 0 || $ask <= 0 || $spread < 0) {~0D~0A    M
sgBox("Quote sanity failed for " + Symbol + ": BID=
" + $bid + " ASK=" + $ask + ". Aborting.");~0D~0A  
  return;~0D~0A}~0D~0A~0D~0A// Projected entry/stop
 based on reference side~0D~0A$pxEntry    = $refPx;
~0D~0A$hypoStop = $pxEntry - $stopLossTrigger;~0D~0A
~0D~0A// ---- Resolve tick increment for safety che
cks (based on current context) ----~0D~0A$inc = 0.0
1;~0D~0Aif ($pxEntry < 1 || $hypoStop < 1 || $bid <
 1 || $ask < 1)        { $inc = 0.001; }~0D~0Aif ($
pxEntry < 0.25 || $hypoStop < 0.25 || $bid < 0.25 |
| $ask < 0.25) { $inc = 0.0005; }~0D~0A~0D~0A// ===
 1) Slippage-aware spread/stop safety (longs) ===~0D
~0A$stopVsBidFail = 0;~0D~0A~0D~0A// margin for saf
ety = max(slipTicksMin * inc, slipSpreadFrac * spre
ad)~0D~0A$slipMargin         = ($slipTicksMin * $in
c);~0D~0A$slipSpreadPart  = ($slipSpreadFrac * $spr
ead);~0D~0Aif ($slipSpreadPart > $slipMargin) { $sl
ipMargin = $slipSpreadPart; }~0D~0A~0D~0Aif ($useSl
ippageMargin == 1) {~0D~0A    // Require stop to be
 below (Bid + margin)~0D~0A    if ($hypoStop >= ($b
id + $slipMargin)) { $stopVsBidFail = 1; }~0D~0A} e
lse {~0D~0A    if ($hypoStop >= $bid) { $stopVsBidF
ail = 1; }~0D~0A}~0D~0A~0D~0A// spread relative to 
stop distance guard (tune threshold as desired)~0D~0A
$spreadTooWide = ($spread > ($stopLossTrigger * 0.7
5)) && $useSpreadCheck == 1;~0D~0A~0D~0A// If eithe
r fails, alert and abort unless we are adding to an
 existing position~0D~0Aif (($stopVsBidFail == 1 ||
 $spreadTooWide == 1) && $posBefore <=0) {~0D~0A   
 $msg = "Spread/Stop safety failed for " + Symbol +
 "\n" +~0D~0A           "Bid: " + $bid + "  Ask: " 
+ $ask + "  Spread: " + $spread + "\n" +~0D~0A     
      "Planned Entry: " + $pxEntry + "  Planned Sto
p: " + $hypoStop + "\n\n";~0D~0A    if ($stopVsBidF
ail == 1)  { $msg = $msg + "- STOP_ABOVE_BID_WITH_M
ARGIN\n"; }~0D~0A    if ($spreadTooWide == 1)  { $m
sg = $msg + "- SPREAD_TOO_WIDE vs stopOff\n"; }~0D~0A
    MsgBox($msg + "\nAction aborted.");~0D~0A    re
turn;~0D~0A}~0D~0A~0D~0A// Per-trade risk cap (proj
ected risk = stopLossTrigger * addShares)~0D~0Aif (
$usePerTradeRiskCap == 1) {~0D~0A    $projRisk = $s
topLossTrigger * $addShares;~0D~0A    if ($projRisk
 > $riskCapDollars) {~0D~0A        MsgBox("Risk cap
 exceeded for " + Symbol + ": projected $" + $projR
isk + " > cap $" + $riskCapDollars + ". Aborting.")
;~0D~0A        return;~0D~0A    }~0D~0A}~0D~0A~0D~0A
// === 2) Cancel only BUY working orders (keep exis
ting protection until we actually fill) ===~0D~0A$a
cc = GetAccountObj(Account);~0D~0A$acc.CancelOrder(
"BUY", Symbol, 0);~0D~0A~0D~0A// === 3) Build entry
; snap entry to increment to reduce rejects ===~0D~0A
// Re-evaluate inc using pxEntry (some symbols jump
 bands)~0D~0A$inc = 0.01;~0D~0Aif ($pxEntry < 1 || 
$bid < 1 || $ask < 1) { $inc = 0.001; }~0D~0Aif ($p
xEntry < 0.25 || $bid < 0.25 || $ask < 0.25) { $inc
 = 0.0005; }~0D~0A$pxEntry = Round($pxEntry, 102, $
inc);~0D~0A~0D~0A$order = NewOrderObj();~0D~0A$orde
r.Account = Account;~0D~0A$order.Symbol  = Symbol;~0D
~0A$order.Route   = "ARCA";~0D~0A$order.Tif     = "
DAY+";~0D~0A$order.Side    = "B";      // Buy~0D~0A
$order.Type    = "L";      // Limit~0D~0A$order.Pri
ce   = $pxEntry;~0D~0A$order.Share   = $addShares;~0D
~0A$order.Send();~0D~0A~0D~0A~0D~0A// === 4) Poll f
or fill (break when criteria met) ===~0D~0A$i      
      = 0;~0D~0A$filled      = 0;~0D~0A$filledQty =
 0;~0D~0Awhile ($i < $maxPolls && $filled == 0) {~0D
~0A    Wait($pollMs);~0D~0A    $order.GetInfo();   
                     // refresh order object~0D~0A 
   $filledQty = $order.Share - $order.Open; // how 
many filled so far~0D~0A    if ($order.Open == 0) {
~0D~0A        $filled = 1; // full fill~0D~0A      
  break;~0D~0A    }~0D~0A    if ($acceptPartial == 
1 && $filledQty >= $minFillShares) {~0D~0A        $
filled = 2; // partial-accepted~0D~0A        break;
~0D~0A    }~0D~0A    $i = $i + 1;~0D~0A}~0D~0A~0D~0A
// throttle between orders~0D~0A$elapsed = $i * $po
llMs;~0D~0Aif ($elapsed < $minDelayMs) {~0D~0A    W
ait($minDelayMs - $elapsed);~0D~0A}~0D~0A~0D~0A// =
== 5) If no acceptable fill, cancel and exit (do no
t touch existing stops) ===~0D~0Aif ($filled == 0) 
{~0D~0A    $order.Cancel();~0D~0A    return;~0D~0A}
~0D~0A~0D~0A// Optional: if we accepted a partial a
nd want to freeze size before arming stop~0D~0Aif (
$filled == 2 && $cancelRemainderOnPartial == 1) {~0D
~0A    $order.Cancel();~0D~0A    // brief wait to l
et the residual cancel~0D~0A    Wait(200);~0D~0A}~0D
~0A~0D~0A// === 6) Arm unified 1R stop via reusable
 ~E2~80~9CSet Auto Stop~E2~80~9D script ===~0D~0Aif
 ($useAutoStop == "Yes") {~0D~0A    ExecHotKey("Set
 Auto Stop");   ~0D~0A}~0D~0A~0D~0A// == 7) Build a
nd set take profit trigger (optional) ==~0D~0A// On
ly (re)build TP if we are NOT already profitable on
 the existing position.~0D~0A// For longs, "profita
ble" means: BID > avgBefore on the position that ex
isted~0D~0A// before this entry. If we're already g
reen, do NOT reset TP.~0D~0Aif ($useTakeProfit == "
Yes") {~0D~0A~0D~0A    // If no position beforehand
, always set TP (fresh trade)~0D~0A    if ($posBefo
re <= 0) {~0D~0A        ExecHotKey("Set Take Profit
");~0D~0A    } else {~0D~0A        // We had a long
 position before this add. Check profitability.~0D~0A
        $bidNow = BID;~0D~0A~0D~0A        // If avg
Before is invalid, be conservative and allow TP res
et~0D~0A        if ($avgBefore <= 0) {~0D~0A       
     ExecHotKey("Set Take Profit");~0D~0A        } 
else {~0D~0A            // Only reset TP if NOT yet
 profitable (bid <= avgBefore)~0D~0A            if 
($bidNow <= $avgBefore) {~0D~0A                Exec
HotKey("Set Take Profit");~0D~0A            }~0D~0A
            // else: already profitable ~E2~86~92 d
o nothing, keep existing TP~0D~0A        }~0D~0A   
 }~0D~0A}~0D~0A~0D~0A// --- End ---
Alt+Shift+2:Buy 50 Ask SL:~ 7437:// =====================~0D~0A//  SCALING-AWARE ENT
RY~0D~0A// =====================~0D~0A~0D~0A// Chec
k rehab flag first~0D~0Aif ($rehab == 1 && $ACCOUNT
_STATE == "live") { MsgBox("ABORTED: Rehabe share s
ize viloation!"); return; }~0D~0A~0D~0AFocusWindow 
Primary_OE;~0D~0A~0D~0A// ---- Global daily-loss gu
ard per account ----~0D~0A$accName = GetVar("DAY_AC
C");~0D~0A$lockKey = "TRADING_LOCKED_" + $accName;~0D
~0A$locked  = GetVar($lockKey) * 1;~0D~0A~0D~0Aif (
$locked == 1) {~0D~0A    MsgBox("Trading locked for
 " + $accName + " (daily loss limit hit).");~0D~0A 
   return;~0D~0A}~0D~0A~0D~0A// Set ENTRY_SYM and c
lear TP_SYMBOL~0D~0A$M = GetWindowObj("Primary_OE")
;~0D~0Aif (IsObj($M)) {~0D~0A    $entrySymbol = $M.
Symb;~0D~0A} else {~0D~0A    $entrySymbol = Symbol;
~0D~0A}~0D~0A$tpSymbol = "";~0D~0A~0D~0A// --- Capt
ure pre-entry position & average cost (for TP logic
) ---~0D~0A$posBefore = 0;~0D~0A$avgBefore = 0;~0D~0A
~0D~0Aif (IsObj($M)) {~0D~0A    $posBefore = $M.Pos
;~0D~0A    $avgBefore = $M.AvgCost;~0D~0A} else {~0D
~0A    $posBefore = Pos;~0D~0A    $avgBefore = AvgC
ost;~0D~0A}~0D~0A~0D~0A// ---- Tunables ----~0D~0A$
addShares     = 50 * $qtyMult;~0D~0A$refPx         
    = ASK;             // BID or ASK~0D~0A$minDelay
Ms  = 1000;           // throttle between order sen
ds (ms)~0D~0A~0D~0A// ---- Max position size guard 
rail ----~0D~0Aif ($maxPositionSize > 0) {    ~0D~0A
    // Determine current position in Primary_OE (fa
llback: Pos)~0D~0A    $curPos = 0;~0D~0A    if (IsO
bj($M)) {~0D~0A        $curPos = $M.Pos;~0D~0A    }
 else {~0D~0A        $curPos = Pos;        // DAS b
uilt-in position for current symbol~0D~0A    }~0D~0A
~0D~0A    // Remaining capacity before hitting the 
guard rail~0D~0A    $remaining = $maxPositionSize -
 $curPos;~0D~0A~0D~0A    // If we're already at / a
bove max, do not allow more size~0D~0A    if ($rema
ining <= 0) {~0D~0A        MsgBox("Max position siz
e reached for " + Symbol + ~0D~0A               " (
" + $maxPositionSize + " shares). No additional siz
e allowed.");~0D~0A        return;~0D~0A    }~0D~0A
~0D~0A    // If this clip would exceed max size, cl
amp it down~0D~0A    if ($addShares > $remaining) {
~0D~0A        $addShares = $remaining;~0D~0A    }~0D
~0A~0D~0A}~0D~0A~0D~0A// ---- Tick-size Bands (no f
unctions; simple if-else ladder) ----~0D~0A// We~E2
~80~99ll resolve the increment later using current 
prices.~0D~0A//   < $0.25  -> 0.0005~0D~0A//   < $1
.00  -> 0.001~0D~0A//   ~E2~89~A5 $1.00  -> 0.01~0D
~0A~0D~0A// === 0) Quote sanity & derived prices fo
r safety check ===~0D~0A$bid    = BID;~0D~0A$ask   
 = ASK;~0D~0A$spread = $ask - $bid;~0D~0A~0D~0Aif (
$bid <= 0 || $ask <= 0 || $spread < 0) {~0D~0A    M
sgBox("Quote sanity failed for " + Symbol + ": BID=
" + $bid + " ASK=" + $ask + ". Aborting.");~0D~0A  
  return;~0D~0A}~0D~0A~0D~0A// Projected entry/stop
 based on reference side~0D~0A$pxEntry    = $refPx;
~0D~0A$hypoStop = $pxEntry - $stopLossTrigger;~0D~0A
~0D~0A// ---- Resolve tick increment for safety che
cks (based on current context) ----~0D~0A$inc = 0.0
1;~0D~0Aif ($pxEntry < 1 || $hypoStop < 1 || $bid <
 1 || $ask < 1)        { $inc = 0.001; }~0D~0Aif ($
pxEntry < 0.25 || $hypoStop < 0.25 || $bid < 0.25 |
| $ask < 0.25) { $inc = 0.0005; }~0D~0A~0D~0A// ===
 1) Slippage-aware spread/stop safety (longs) ===~0D
~0A$stopVsBidFail = 0;~0D~0A~0D~0A// margin for saf
ety = max(slipTicksMin * inc, slipSpreadFrac * spre
ad)~0D~0A$slipMargin         = ($slipTicksMin * $in
c);~0D~0A$slipSpreadPart  = ($slipSpreadFrac * $spr
ead);~0D~0Aif ($slipSpreadPart > $slipMargin) { $sl
ipMargin = $slipSpreadPart; }~0D~0A~0D~0Aif ($useSl
ippageMargin == 1) {~0D~0A    // Require stop to be
 below (Bid + margin)~0D~0A    if ($hypoStop >= ($b
id + $slipMargin)) { $stopVsBidFail = 1; }~0D~0A} e
lse {~0D~0A    if ($hypoStop >= $bid) { $stopVsBidF
ail = 1; }~0D~0A}~0D~0A~0D~0A// spread relative to 
stop distance guard (tune threshold as desired)~0D~0A
$spreadTooWide = ($spread > ($stopLossTrigger * 0.7
5)) && $useSpreadCheck == 1;~0D~0A~0D~0A// If eithe
r fails, alert and abort unless we are adding to an
 existing position~0D~0Aif (($stopVsBidFail == 1 ||
 $spreadTooWide == 1) && $posBefore <=0) {~0D~0A   
 $msg = "Spread/Stop safety failed for " + Symbol +
 "\n" +~0D~0A           "Bid: " + $bid + "  Ask: " 
+ $ask + "  Spread: " + $spread + "\n" +~0D~0A     
      "Planned Entry: " + $pxEntry + "  Planned Sto
p: " + $hypoStop + "\n\n";~0D~0A    if ($stopVsBidF
ail == 1)  { $msg = $msg + "- STOP_ABOVE_BID_WITH_M
ARGIN\n"; }~0D~0A    if ($spreadTooWide == 1)  { $m
sg = $msg + "- SPREAD_TOO_WIDE vs stopOff\n"; }~0D~0A
    MsgBox($msg + "\nAction aborted.");~0D~0A    re
turn;~0D~0A}~0D~0A~0D~0A// Per-trade risk cap (proj
ected risk = stopLossTrigger * addShares)~0D~0Aif (
$usePerTradeRiskCap == 1) {~0D~0A    $projRisk = $s
topLossTrigger * $addShares;~0D~0A    if ($projRisk
 > $riskCapDollars) {~0D~0A        MsgBox("Risk cap
 exceeded for " + Symbol + ": projected $" + $projR
isk + " > cap $" + $riskCapDollars + ". Aborting.")
;~0D~0A        return;~0D~0A    }~0D~0A}~0D~0A~0D~0A
// === 2) Cancel only BUY working orders (keep exis
ting protection until we actually fill) ===~0D~0A$a
cc = GetAccountObj(Account);~0D~0A$acc.CancelOrder(
"BUY", Symbol, 0);~0D~0A~0D~0A// === 3) Build entry
; snap entry to increment to reduce rejects ===~0D~0A
// Re-evaluate inc using pxEntry (some symbols jump
 bands)~0D~0A$inc = 0.01;~0D~0Aif ($pxEntry < 1 || 
$bid < 1 || $ask < 1) { $inc = 0.001; }~0D~0Aif ($p
xEntry < 0.25 || $bid < 0.25 || $ask < 0.25) { $inc
 = 0.0005; }~0D~0A$pxEntry = Round($pxEntry, 102, $
inc);~0D~0A~0D~0A$order = NewOrderObj();~0D~0A$orde
r.Account = Account;~0D~0A$order.Symbol  = Symbol;~0D
~0A$order.Route   = "ARCA";~0D~0A$order.Tif     = "
DAY+";~0D~0A$order.Side    = "B";      // Buy~0D~0A
$order.Type    = "L";      // Limit~0D~0A$order.Pri
ce   = $pxEntry;~0D~0A$order.Share   = $addShares;~0D
~0A$order.Send();~0D~0A~0D~0A~0D~0A// === 4) Poll f
or fill (break when criteria met) ===~0D~0A$i      
      = 0;~0D~0A$filled      = 0;~0D~0A$filledQty =
 0;~0D~0Awhile ($i < $maxPolls && $filled == 0) {~0D
~0A    Wait($pollMs);~0D~0A    $order.GetInfo();   
                     // refresh order object~0D~0A 
   $filledQty = $order.Share - $order.Open; // how 
many filled so far~0D~0A    if ($order.Open == 0) {
~0D~0A        $filled = 1; // full fill~0D~0A      
  break;~0D~0A    }~0D~0A    if ($acceptPartial == 
1 && $filledQty >= $minFillShares) {~0D~0A        $
filled = 2; // partial-accepted~0D~0A        break;
~0D~0A    }~0D~0A    $i = $i + 1;~0D~0A}~0D~0A~0D~0A
// throttle between orders~0D~0A$elapsed = $i * $po
llMs;~0D~0Aif ($elapsed < $minDelayMs) {~0D~0A    W
ait($minDelayMs - $elapsed);~0D~0A}~0D~0A~0D~0A// =
== 5) If no acceptable fill, cancel and exit (do no
t touch existing stops) ===~0D~0Aif ($filled == 0) 
{~0D~0A    $order.Cancel();~0D~0A    return;~0D~0A}
~0D~0A~0D~0A// Optional: if we accepted a partial a
nd want to freeze size before arming stop~0D~0Aif (
$filled == 2 && $cancelRemainderOnPartial == 1) {~0D
~0A    $order.Cancel();~0D~0A    // brief wait to l
et the residual cancel~0D~0A    Wait(200);~0D~0A}~0D
~0A~0D~0A// === 6) Arm unified 1R stop via reusable
 ~E2~80~9CSet Auto Stop~E2~80~9D script ===~0D~0Aif
 ($useAutoStop == "Yes") {~0D~0A    ExecHotKey("Set
 Auto Stop");   ~0D~0A}~0D~0A~0D~0A// == 7) Build a
nd set take profit trigger (optional) ==~0D~0A// On
ly (re)build TP if we are NOT already profitable on
 the existing position.~0D~0A// For longs, "profita
ble" means: BID > avgBefore on the position that ex
isted~0D~0A// before this entry. If we're already g
reen, do NOT reset TP.~0D~0Aif ($useTakeProfit == "
Yes") {~0D~0A~0D~0A    // If no position beforehand
, always set TP (fresh trade)~0D~0A    if ($posBefo
re <= 0) {~0D~0A        ExecHotKey("Set Take Profit
");~0D~0A    } else {~0D~0A        // We had a long
 position before this add. Check profitability.~0D~0A
        $bidNow = BID;~0D~0A~0D~0A        // If avg
Before is invalid, be conservative and allow TP res
et~0D~0A        if ($avgBefore <= 0) {~0D~0A       
     ExecHotKey("Set Take Profit");~0D~0A        } 
else {~0D~0A            // Only reset TP if NOT yet
 profitable (bid <= avgBefore)~0D~0A            if 
($bidNow <= $avgBefore) {~0D~0A                Exec
HotKey("Set Take Profit");~0D~0A            }~0D~0A
            // else: already profitable ~E2~86~92 d
o nothing, keep existing TP~0D~0A        }~0D~0A   
 }~0D~0A}~0D~0A~0D~0A// --- End ---
Alt+Shift+3:Buy 100 Ask SL:~ 7438:// =====================~0D~0A//  SCALING-AWARE ENT
RY~0D~0A// =====================~0D~0A~0D~0A// Chec
k rehab flag first~0D~0Aif ($rehab == 1 && $ACCOUNT
_STATE == "live") { MsgBox("ABORTED: Rehabe share s
ize viloation!"); return; }~0D~0A~0D~0AFocusWindow 
Primary_OE;~0D~0A~0D~0A// ---- Global daily-loss gu
ard per account ----~0D~0A$accName = GetVar("DAY_AC
C");~0D~0A$lockKey = "TRADING_LOCKED_" + $accName;~0D
~0A$locked  = GetVar($lockKey) * 1;~0D~0A~0D~0Aif (
$locked == 1) {~0D~0A    MsgBox("Trading locked for
 " + $accName + " (daily loss limit hit).");~0D~0A 
   return;~0D~0A}~0D~0A~0D~0A// Set ENTRY_SYM and c
lear TP_SYMBOL~0D~0A$M = GetWindowObj("Primary_OE")
;~0D~0Aif (IsObj($M)) {~0D~0A    $entrySymbol = $M.
Symb;~0D~0A} else {~0D~0A    $entrySymbol = Symbol;
~0D~0A}~0D~0A$tpSymbol = "";~0D~0A~0D~0A// --- Capt
ure pre-entry position & average cost (for TP logic
) ---~0D~0A$posBefore = 0;~0D~0A$avgBefore = 0;~0D~0A
~0D~0Aif (IsObj($M)) {~0D~0A    $posBefore = $M.Pos
;~0D~0A    $avgBefore = $M.AvgCost;~0D~0A} else {~0D
~0A    $posBefore = Pos;~0D~0A    $avgBefore = AvgC
ost;~0D~0A}~0D~0A~0D~0A// ---- Tunables ----~0D~0A$
addShares     = 100 * $qtyMult;~0D~0A$refPx        
     = ASK;             // BID or ASK~0D~0A$minDela
yMs  = 1000;           // throttle between order se
nds (ms)~0D~0A~0D~0A// ---- Max position size guard
 rail ----~0D~0Aif ($maxPositionSize > 0) {    ~0D~0A
    // Determine current position in Primary_OE (fa
llback: Pos)~0D~0A    $curPos = 0;~0D~0A    if (IsO
bj($M)) {~0D~0A        $curPos = $M.Pos;~0D~0A    }
 else {~0D~0A        $curPos = Pos;        // DAS b
uilt-in position for current symbol~0D~0A    }~0D~0A
~0D~0A    // Remaining capacity before hitting the 
guard rail~0D~0A    $remaining = $maxPositionSize -
 $curPos;~0D~0A~0D~0A    // If we're already at / a
bove max, do not allow more size~0D~0A    if ($rema
ining <= 0) {~0D~0A        MsgBox("Max position siz
e reached for " + Symbol + ~0D~0A               " (
" + $maxPositionSize + " shares). No additional siz
e allowed.");~0D~0A        return;~0D~0A    }~0D~0A
~0D~0A    // If this clip would exceed max size, cl
amp it down~0D~0A    if ($addShares > $remaining) {
~0D~0A        $addShares = $remaining;~0D~0A    }~0D
~0A~0D~0A}~0D~0A~0D~0A// ---- Tick-size Bands (no f
unctions; simple if-else ladder) ----~0D~0A// We~E2
~80~99ll resolve the increment later using current 
prices.~0D~0A//   < $0.25  -> 0.0005~0D~0A//   < $1
.00  -> 0.001~0D~0A//   ~E2~89~A5 $1.00  -> 0.01~0D
~0A~0D~0A// === 0) Quote sanity & derived prices fo
r safety check ===~0D~0A$bid    = BID;~0D~0A$ask   
 = ASK;~0D~0A$spread = $ask - $bid;~0D~0A~0D~0Aif (
$bid <= 0 || $ask <= 0 || $spread < 0) {~0D~0A    M
sgBox("Quote sanity failed for " + Symbol + ": BID=
" + $bid + " ASK=" + $ask + ". Aborting.");~0D~0A  
  return;~0D~0A}~0D~0A~0D~0A// Projected entry/stop
 based on reference side~0D~0A$pxEntry    = $refPx;
~0D~0A$hypoStop = $pxEntry - $stopLossTrigger;~0D~0A
~0D~0A// ---- Resolve tick increment for safety che
cks (based on current context) ----~0D~0A$inc = 0.0
1;~0D~0Aif ($pxEntry < 1 || $hypoStop < 1 || $bid <
 1 || $ask < 1)        { $inc = 0.001; }~0D~0Aif ($
pxEntry < 0.25 || $hypoStop < 0.25 || $bid < 0.25 |
| $ask < 0.25) { $inc = 0.0005; }~0D~0A~0D~0A// ===
 1) Slippage-aware spread/stop safety (longs) ===~0D
~0A$stopVsBidFail = 0;~0D~0A~0D~0A// margin for saf
ety = max(slipTicksMin * inc, slipSpreadFrac * spre
ad)~0D~0A$slipMargin         = ($slipTicksMin * $in
c);~0D~0A$slipSpreadPart  = ($slipSpreadFrac * $spr
ead);~0D~0Aif ($slipSpreadPart > $slipMargin) { $sl
ipMargin = $slipSpreadPart; }~0D~0A~0D~0Aif ($useSl
ippageMargin == 1) {~0D~0A    // Require stop to be
 below (Bid + margin)~0D~0A    if ($hypoStop >= ($b
id + $slipMargin)) { $stopVsBidFail = 1; }~0D~0A} e
lse {~0D~0A    if ($hypoStop >= $bid) { $stopVsBidF
ail = 1; }~0D~0A}~0D~0A~0D~0A// spread relative to 
stop distance guard (tune threshold as desired)~0D~0A
$spreadTooWide = ($spread > ($stopLossTrigger * 0.7
5)) && $useSpreadCheck == 1;~0D~0A~0D~0A// If eithe
r fails, alert and abort unless we are adding to an
 existing position~0D~0Aif (($stopVsBidFail == 1 ||
 $spreadTooWide == 1) && $posBefore <=0) {~0D~0A   
 $msg = "Spread/Stop safety failed for " + Symbol +
 "\n" +~0D~0A           "Bid: " + $bid + "  Ask: " 
+ $ask + "  Spread: " + $spread + "\n" +~0D~0A     
      "Planned Entry: " + $pxEntry + "  Planned Sto
p: " + $hypoStop + "\n\n";~0D~0A    if ($stopVsBidF
ail == 1)  { $msg = $msg + "- STOP_ABOVE_BID_WITH_M
ARGIN\n"; }~0D~0A    if ($spreadTooWide == 1)  { $m
sg = $msg + "- SPREAD_TOO_WIDE vs stopOff\n"; }~0D~0A
    MsgBox($msg + "\nAction aborted.");~0D~0A    re
turn;~0D~0A}~0D~0A~0D~0A// Per-trade risk cap (proj
ected risk = stopLossTrigger * addShares)~0D~0Aif (
$usePerTradeRiskCap == 1) {~0D~0A    $projRisk = $s
topLossTrigger * $addShares;~0D~0A    if ($projRisk
 > $riskCapDollars) {~0D~0A        MsgBox("Risk cap
 exceeded for " + Symbol + ": projected $" + $projR
isk + " > cap $" + $riskCapDollars + ". Aborting.")
;~0D~0A        return;~0D~0A    }~0D~0A}~0D~0A~0D~0A
// === 2) Cancel only BUY working orders (keep exis
ting protection until we actually fill) ===~0D~0A$a
cc = GetAccountObj(Account);~0D~0A$acc.CancelOrder(
"BUY", Symbol, 0);~0D~0A~0D~0A// === 3) Build entry
; snap entry to increment to reduce rejects ===~0D~0A
// Re-evaluate inc using pxEntry (some symbols jump
 bands)~0D~0A$inc = 0.01;~0D~0Aif ($pxEntry < 1 || 
$bid < 1 || $ask < 1) { $inc = 0.001; }~0D~0Aif ($p
xEntry < 0.25 || $bid < 0.25 || $ask < 0.25) { $inc
 = 0.0005; }~0D~0A$pxEntry = Round($pxEntry, 102, $
inc);~0D~0A~0D~0A$order = NewOrderObj();~0D~0A$orde
r.Account = Account;~0D~0A$order.Symbol  = Symbol;~0D
~0A$order.Route   = "ARCA";~0D~0A$order.Tif     = "
DAY+";~0D~0A$order.Side    = "B";      // Buy~0D~0A
$order.Type    = "L";      // Limit~0D~0A$order.Pri
ce   = $pxEntry;~0D~0A$order.Share   = $addShares;~0D
~0A$order.Send();~0D~0A~0D~0A~0D~0A// === 4) Poll f
or fill (break when criteria met) ===~0D~0A$i      
      = 0;~0D~0A$filled      = 0;~0D~0A$filledQty =
 0;~0D~0Awhile ($i < $maxPolls && $filled == 0) {~0D
~0A    Wait($pollMs);~0D~0A    $order.GetInfo();   
                     // refresh order object~0D~0A 
   $filledQty = $order.Share - $order.Open; // how 
many filled so far~0D~0A    if ($order.Open == 0) {
~0D~0A        $filled = 1; // full fill~0D~0A      
  break;~0D~0A    }~0D~0A    if ($acceptPartial == 
1 && $filledQty >= $minFillShares) {~0D~0A        $
filled = 2; // partial-accepted~0D~0A        break;
~0D~0A    }~0D~0A    $i = $i + 1;~0D~0A}~0D~0A~0D~0A
// throttle between orders~0D~0A$elapsed = $i * $po
llMs;~0D~0Aif ($elapsed < $minDelayMs) {~0D~0A    W
ait($minDelayMs - $elapsed);~0D~0A}~0D~0A~0D~0A// =
== 5) If no acceptable fill, cancel and exit (do no
t touch existing stops) ===~0D~0Aif ($filled == 0) 
{~0D~0A    $order.Cancel();~0D~0A    return;~0D~0A}
~0D~0A~0D~0A// Optional: if we accepted a partial a
nd want to freeze size before arming stop~0D~0Aif (
$filled == 2 && $cancelRemainderOnPartial == 1) {~0D
~0A    $order.Cancel();~0D~0A    // brief wait to l
et the residual cancel~0D~0A    Wait(200);~0D~0A}~0D
~0A~0D~0A// === 6) Arm unified 1R stop via reusable
 ~E2~80~9CSet Auto Stop~E2~80~9D script ===~0D~0Aif
 ($useAutoStop == "Yes") {~0D~0A    ExecHotKey("Set
 Auto Stop");   ~0D~0A}~0D~0A~0D~0A// == 7) Build a
nd set take profit trigger (optional) ==~0D~0A// On
ly (re)build TP if we are NOT already profitable on
 the existing position.~0D~0A// For longs, "profita
ble" means: BID > avgBefore on the position that ex
isted~0D~0A// before this entry. If we're already g
reen, do NOT reset TP.~0D~0Aif ($useTakeProfit == "
Yes") {~0D~0A~0D~0A    // If no position beforehand
, always set TP (fresh trade)~0D~0A    if ($posBefo
re <= 0) {~0D~0A        ExecHotKey("Set Take Profit
");~0D~0A    } else {~0D~0A        // We had a long
 position before this add. Check profitability.~0D~0A
        $bidNow = BID;~0D~0A~0D~0A        // If avg
Before is invalid, be conservative and allow TP res
et~0D~0A        if ($avgBefore <= 0) {~0D~0A       
     ExecHotKey("Set Take Profit");~0D~0A        } 
else {~0D~0A            // Only reset TP if NOT yet
 profitable (bid <= avgBefore)~0D~0A            if 
($bidNow <= $avgBefore) {~0D~0A                Exec
HotKey("Set Take Profit");~0D~0A            }~0D~0A
            // else: already profitable ~E2~86~92 d
o nothing, keep existing TP~0D~0A        }~0D~0A   
 }~0D~0A}~0D~0A~0D~0A// --- End ---
Alt+Shift+4:Buy 150 Ask SL:~ 7438:// =====================~0D~0A//  SCALING-AWARE ENT
RY~0D~0A// =====================~0D~0A~0D~0A// Chec
k rehab flag first~0D~0Aif ($rehab == 1 && $ACCOUNT
_STATE == "live") { MsgBox("ABORTED: Rehabe share s
ize viloation!"); return; }~0D~0A~0D~0AFocusWindow 
Primary_OE;~0D~0A~0D~0A// ---- Global daily-loss gu
ard per account ----~0D~0A$accName = GetVar("DAY_AC
C");~0D~0A$lockKey = "TRADING_LOCKED_" + $accName;~0D
~0A$locked  = GetVar($lockKey) * 1;~0D~0A~0D~0Aif (
$locked == 1) {~0D~0A    MsgBox("Trading locked for
 " + $accName + " (daily loss limit hit).");~0D~0A 
   return;~0D~0A}~0D~0A~0D~0A// Set ENTRY_SYM and c
lear TP_SYMBOL~0D~0A$M = GetWindowObj("Primary_OE")
;~0D~0Aif (IsObj($M)) {~0D~0A    $entrySymbol = $M.
Symb;~0D~0A} else {~0D~0A    $entrySymbol = Symbol;
~0D~0A}~0D~0A$tpSymbol = "";~0D~0A~0D~0A// --- Capt
ure pre-entry position & average cost (for TP logic
) ---~0D~0A$posBefore = 0;~0D~0A$avgBefore = 0;~0D~0A
~0D~0Aif (IsObj($M)) {~0D~0A    $posBefore = $M.Pos
;~0D~0A    $avgBefore = $M.AvgCost;~0D~0A} else {~0D
~0A    $posBefore = Pos;~0D~0A    $avgBefore = AvgC
ost;~0D~0A}~0D~0A~0D~0A// ---- Tunables ----~0D~0A$
addShares     = 150 * $qtyMult;~0D~0A$refPx        
     = ASK;             // BID or ASK~0D~0A$minDela
yMs  = 1000;           // throttle between order se
nds (ms)~0D~0A~0D~0A// ---- Max position size guard
 rail ----~0D~0Aif ($maxPositionSize > 0) {    ~0D~0A
    // Determine current position in Primary_OE (fa
llback: Pos)~0D~0A    $curPos = 0;~0D~0A    if (IsO
bj($M)) {~0D~0A        $curPos = $M.Pos;~0D~0A    }
 else {~0D~0A        $curPos = Pos;        // DAS b
uilt-in position for current symbol~0D~0A    }~0D~0A
~0D~0A    // Remaining capacity before hitting the 
guard rail~0D~0A    $remaining = $maxPositionSize -
 $curPos;~0D~0A~0D~0A    // If we're already at / a
bove max, do not allow more size~0D~0A    if ($rema
ining <= 0) {~0D~0A        MsgBox("Max position siz
e reached for " + Symbol + ~0D~0A               " (
" + $maxPositionSize + " shares). No additional siz
e allowed.");~0D~0A        return;~0D~0A    }~0D~0A
~0D~0A    // If this clip would exceed max size, cl
amp it down~0D~0A    if ($addShares > $remaining) {
~0D~0A        $addShares = $remaining;~0D~0A    }~0D
~0A~0D~0A}~0D~0A~0D~0A// ---- Tick-size Bands (no f
unctions; simple if-else ladder) ----~0D~0A// We~E2
~80~99ll resolve the increment later using current 
prices.~0D~0A//   < $0.25  -> 0.0005~0D~0A//   < $1
.00  -> 0.001~0D~0A//   ~E2~89~A5 $1.00  -> 0.01~0D
~0A~0D~0A// === 0) Quote sanity & derived prices fo
r safety check ===~0D~0A$bid    = BID;~0D~0A$ask   
 = ASK;~0D~0A$spread = $ask - $bid;~0D~0A~0D~0Aif (
$bid <= 0 || $ask <= 0 || $spread < 0) {~0D~0A    M
sgBox("Quote sanity failed for " + Symbol + ": BID=
" + $bid + " ASK=" + $ask + ". Aborting.");~0D~0A  
  return;~0D~0A}~0D~0A~0D~0A// Projected entry/stop
 based on reference side~0D~0A$pxEntry    = $refPx;
~0D~0A$hypoStop = $pxEntry - $stopLossTrigger;~0D~0A
~0D~0A// ---- Resolve tick increment for safety che
cks (based on current context) ----~0D~0A$inc = 0.0
1;~0D~0Aif ($pxEntry < 1 || $hypoStop < 1 || $bid <
 1 || $ask < 1)        { $inc = 0.001; }~0D~0Aif ($
pxEntry < 0.25 || $hypoStop < 0.25 || $bid < 0.25 |
| $ask < 0.25) { $inc = 0.0005; }~0D~0A~0D~0A// ===
 1) Slippage-aware spread/stop safety (longs) ===~0D
~0A$stopVsBidFail = 0;~0D~0A~0D~0A// margin for saf
ety = max(slipTicksMin * inc, slipSpreadFrac * spre
ad)~0D~0A$slipMargin         = ($slipTicksMin * $in
c);~0D~0A$slipSpreadPart  = ($slipSpreadFrac * $spr
ead);~0D~0Aif ($slipSpreadPart > $slipMargin) { $sl
ipMargin = $slipSpreadPart; }~0D~0A~0D~0Aif ($useSl
ippageMargin == 1) {~0D~0A    // Require stop to be
 below (Bid + margin)~0D~0A    if ($hypoStop >= ($b
id + $slipMargin)) { $stopVsBidFail = 1; }~0D~0A} e
lse {~0D~0A    if ($hypoStop >= $bid) { $stopVsBidF
ail = 1; }~0D~0A}~0D~0A~0D~0A// spread relative to 
stop distance guard (tune threshold as desired)~0D~0A
$spreadTooWide = ($spread > ($stopLossTrigger * 0.7
5)) && $useSpreadCheck == 1;~0D~0A~0D~0A// If eithe
r fails, alert and abort unless we are adding to an
 existing position~0D~0Aif (($stopVsBidFail == 1 ||
 $spreadTooWide == 1) && $posBefore <=0) {~0D~0A   
 $msg = "Spread/Stop safety failed for " + Symbol +
 "\n" +~0D~0A           "Bid: " + $bid + "  Ask: " 
+ $ask + "  Spread: " + $spread + "\n" +~0D~0A     
      "Planned Entry: " + $pxEntry + "  Planned Sto
p: " + $hypoStop + "\n\n";~0D~0A    if ($stopVsBidF
ail == 1)  { $msg = $msg + "- STOP_ABOVE_BID_WITH_M
ARGIN\n"; }~0D~0A    if ($spreadTooWide == 1)  { $m
sg = $msg + "- SPREAD_TOO_WIDE vs stopOff\n"; }~0D~0A
    MsgBox($msg + "\nAction aborted.");~0D~0A    re
turn;~0D~0A}~0D~0A~0D~0A// Per-trade risk cap (proj
ected risk = stopLossTrigger * addShares)~0D~0Aif (
$usePerTradeRiskCap == 1) {~0D~0A    $projRisk = $s
topLossTrigger * $addShares;~0D~0A    if ($projRisk
 > $riskCapDollars) {~0D~0A        MsgBox("Risk cap
 exceeded for " + Symbol + ": projected $" + $projR
isk + " > cap $" + $riskCapDollars + ". Aborting.")
;~0D~0A        return;~0D~0A    }~0D~0A}~0D~0A~0D~0A
// === 2) Cancel only BUY working orders (keep exis
ting protection until we actually fill) ===~0D~0A$a
cc = GetAccountObj(Account);~0D~0A$acc.CancelOrder(
"BUY", Symbol, 0);~0D~0A~0D~0A// === 3) Build entry
; snap entry to increment to reduce rejects ===~0D~0A
// Re-evaluate inc using pxEntry (some symbols jump
 bands)~0D~0A$inc = 0.01;~0D~0Aif ($pxEntry < 1 || 
$bid < 1 || $ask < 1) { $inc = 0.001; }~0D~0Aif ($p
xEntry < 0.25 || $bid < 0.25 || $ask < 0.25) { $inc
 = 0.0005; }~0D~0A$pxEntry = Round($pxEntry, 102, $
inc);~0D~0A~0D~0A$order = NewOrderObj();~0D~0A$orde
r.Account = Account;~0D~0A$order.Symbol  = Symbol;~0D
~0A$order.Route   = "ARCA";~0D~0A$order.Tif     = "
DAY+";~0D~0A$order.Side    = "B";      // Buy~0D~0A
$order.Type    = "L";      // Limit~0D~0A$order.Pri
ce   = $pxEntry;~0D~0A$order.Share   = $addShares;~0D
~0A$order.Send();~0D~0A~0D~0A~0D~0A// === 4) Poll f
or fill (break when criteria met) ===~0D~0A$i      
      = 0;~0D~0A$filled      = 0;~0D~0A$filledQty =
 0;~0D~0Awhile ($i < $maxPolls && $filled == 0) {~0D
~0A    Wait($pollMs);~0D~0A    $order.GetInfo();   
                     // refresh order object~0D~0A 
   $filledQty = $order.Share - $order.Open; // how 
many filled so far~0D~0A    if ($order.Open == 0) {
~0D~0A        $filled = 1; // full fill~0D~0A      
  break;~0D~0A    }~0D~0A    if ($acceptPartial == 
1 && $filledQty >= $minFillShares) {~0D~0A        $
filled = 2; // partial-accepted~0D~0A        break;
~0D~0A    }~0D~0A    $i = $i + 1;~0D~0A}~0D~0A~0D~0A
// throttle between orders~0D~0A$elapsed = $i * $po
llMs;~0D~0Aif ($elapsed < $minDelayMs) {~0D~0A    W
ait($minDelayMs - $elapsed);~0D~0A}~0D~0A~0D~0A// =
== 5) If no acceptable fill, cancel and exit (do no
t touch existing stops) ===~0D~0Aif ($filled == 0) 
{~0D~0A    $order.Cancel();~0D~0A    return;~0D~0A}
~0D~0A~0D~0A// Optional: if we accepted a partial a
nd want to freeze size before arming stop~0D~0Aif (
$filled == 2 && $cancelRemainderOnPartial == 1) {~0D
~0A    $order.Cancel();~0D~0A    // brief wait to l
et the residual cancel~0D~0A    Wait(200);~0D~0A}~0D
~0A~0D~0A// === 6) Arm unified 1R stop via reusable
 ~E2~80~9CSet Auto Stop~E2~80~9D script ===~0D~0Aif
 ($useAutoStop == "Yes") {~0D~0A    ExecHotKey("Set
 Auto Stop");   ~0D~0A}~0D~0A~0D~0A// == 7) Build a
nd set take profit trigger (optional) ==~0D~0A// On
ly (re)build TP if we are NOT already profitable on
 the existing position.~0D~0A// For longs, "profita
ble" means: BID > avgBefore on the position that ex
isted~0D~0A// before this entry. If we're already g
reen, do NOT reset TP.~0D~0Aif ($useTakeProfit == "
Yes") {~0D~0A~0D~0A    // If no position beforehand
, always set TP (fresh trade)~0D~0A    if ($posBefo
re <= 0) {~0D~0A        ExecHotKey("Set Take Profit
");~0D~0A    } else {~0D~0A        // We had a long
 position before this add. Check profitability.~0D~0A
        $bidNow = BID;~0D~0A~0D~0A        // If avg
Before is invalid, be conservative and allow TP res
et~0D~0A        if ($avgBefore <= 0) {~0D~0A       
     ExecHotKey("Set Take Profit");~0D~0A        } 
else {~0D~0A            // Only reset TP if NOT yet
 profitable (bid <= avgBefore)~0D~0A            if 
($bidNow <= $avgBefore) {~0D~0A                Exec
HotKey("Set Take Profit");~0D~0A            }~0D~0A
            // else: already profitable ~E2~86~92 d
o nothing, keep existing TP~0D~0A        }~0D~0A   
 }~0D~0A}~0D~0A~0D~0A// --- End ---
Alt+Ctrl+Shift+1:Buy 10 Ask+ SL:~ 7578:// =====================~0D~0A//  SCALING-AWARE ENT
RY~0D~0A// =====================~0D~0A~0D~0AFocusWi
ndow Primary_OE;~0D~0A~0D~0A// ---- Global daily-lo
ss guard per account ----~0D~0A$accName = GetVar("D
AY_ACC");~0D~0A$lockKey = "TRADING_LOCKED_" + $accN
ame;~0D~0A$locked  = GetVar($lockKey) * 1;~0D~0A~0D
~0Aif ($locked == 1) {~0D~0A    MsgBox("Trading loc
ked for " + $accName + " (daily loss limit hit).");
~0D~0A    return;~0D~0A}~0D~0A~0D~0A// Set ENTRY_SY
M and clear TP_SYMBOL~0D~0A$M = GetWindowObj("Prima
ry_OE");~0D~0Aif (IsObj($M)) {~0D~0A    $entrySymbo
l = $M.Symb;~0D~0A} else {~0D~0A    $entrySymbol = 
Symbol;~0D~0A}~0D~0A$tpSymbol = "";~0D~0A~0D~0A// -
-- Capture pre-entry position & average cost (for T
P logic) ---~0D~0A$posBefore = 0;~0D~0A$avgBefore =
 0;~0D~0A~0D~0Aif (IsObj($M)) {~0D~0A    $posBefore
 = $M.Pos;~0D~0A    $avgBefore = $M.AvgCost;~0D~0A}
 else {~0D~0A    $posBefore = Pos;~0D~0A    $avgBef
ore = AvgCost;~0D~0A}~0D~0A~0D~0Aif ($rehab ==1 && 
$M.Pos > 0 && $ACCOUNT_STATE == "live") {~0D~0A    
MsgBox("ABORTED: Rehab size violation, scaling in n
ot allowed!");~0D~0A    return;~0D~0A}~0D~0A~0D~0A/
/ Ice Breaker = 1/4 of normal share size~0D~0A$quar
ter = 50 * $qtyMult * 0.25;~0D~0A$scaled = $quarter
 + 2.5;~0D~0A$addShares = $scaled - ($scaled % 5);~0D
~0A~0D~0A// ---- Tunables ----~0D~0A$refPx         
    = ASK;             // BID or ASK~0D~0A$minDelay
Ms  = 1000;           // throttle between order sen
ds (ms)~0D~0A~0D~0A// ---- Max position size guard 
rail ----~0D~0Aif ($maxPositionSize > 0) {    ~0D~0A
    // Determine current position in Primary_OE (fa
llback: Pos)~0D~0A    $curPos = 0;~0D~0A    if (IsO
bj($M)) {~0D~0A        $curPos = $M.Pos;~0D~0A    }
 else {~0D~0A        $curPos = Pos;        // DAS b
uilt-in position for current symbol~0D~0A    }~0D~0A
~0D~0A    // Remaining capacity before hitting the 
guard rail~0D~0A    $remaining = $maxPositionSize -
 $curPos;~0D~0A~0D~0A    // If we're already at / a
bove max, do not allow more size~0D~0A    if ($rema
ining <= 0) {~0D~0A        MsgBox("Max position siz
e reached for " + Symbol + ~0D~0A               " (
" + $maxPositionSize + " shares). No additional siz
e allowed.");~0D~0A        return;~0D~0A    }~0D~0A
~0D~0A    // If this clip would exceed max size, cl
amp it down~0D~0A    if ($addShares > $remaining) {
~0D~0A        $addShares = $remaining;~0D~0A    }~0D
~0A~0D~0A}~0D~0A~0D~0A// ---- Tick-size Bands (no f
unctions; simple if-else ladder) ----~0D~0A// We~E2
~80~99ll resolve the increment later using current 
prices.~0D~0A//   < $0.25  -> 0.0005~0D~0A//   < $1
.00  -> 0.001~0D~0A//   ~E2~89~A5 $1.00  -> 0.01~0D
~0A~0D~0A// === 0) Quote sanity & derived prices fo
r safety check ===~0D~0A$bid    = BID;~0D~0A$ask   
 = ASK;~0D~0A$spread = $ask - $bid;~0D~0A~0D~0Aif (
$bid <= 0 || $ask <= 0 || $spread < 0) {~0D~0A    M
sgBox("Quote sanity failed for " + Symbol + ": BID=
" + $bid + " ASK=" + $ask + ". Aborting.");~0D~0A  
  return;~0D~0A}~0D~0A~0D~0A// Projected entry/stop
 based on reference side~0D~0A$pxEntry    = $refPx 
+ $entryOffset;~0D~0A$hypoStop = $pxEntry - $stopLo
ssTrigger;~0D~0A~0D~0A// ---- Resolve tick incremen
t for safety checks (based on current context) ----
~0D~0A$inc = 0.01;~0D~0Aif ($pxEntry < 1 || $hypoSt
op < 1 || $bid < 1 || $ask < 1)        { $inc = 0.0
01; }~0D~0Aif ($pxEntry < 0.25 || $hypoStop < 0.25 
|| $bid < 0.25 || $ask < 0.25) { $inc = 0.0005; }~0D
~0A~0D~0A// === 1) Slippage-aware spread/stop safet
y (longs) ===~0D~0A$stopVsBidFail = 0;~0D~0A~0D~0A/
/ margin for safety = max(slipTicksMin * inc, slipS
preadFrac * spread)~0D~0A$slipMargin         = ($sl
ipTicksMin * $inc);~0D~0A$slipSpreadPart  = ($slipS
preadFrac * $spread);~0D~0Aif ($slipSpreadPart > $s
lipMargin) { $slipMargin = $slipSpreadPart; }~0D~0A
~0D~0Aif ($useSlippageMargin == 1) {~0D~0A    // Re
quire stop to be below (Bid + margin)~0D~0A    if (
$hypoStop >= ($bid + $slipMargin)) { $stopVsBidFail
 = 1; }~0D~0A} else {~0D~0A    if ($hypoStop >= $bi
d) { $stopVsBidFail = 1; }~0D~0A}~0D~0A~0D~0A// spr
ead relative to stop distance guard (tune threshold
 as desired)~0D~0A$spreadTooWide = ($spread > ($sto
pLossTrigger * 0.75)) && $useSpreadCheck == 1;~0D~0A
~0D~0A// If either fails, alert and abort unless we
 are adding to an existing position~0D~0Aif (($stop
VsBidFail == 1 || $spreadTooWide == 1) && $posBefor
e <=0) {~0D~0A    $msg = "Spread/Stop safety failed
 for " + Symbol + "\n" +~0D~0A           "Bid: " + 
$bid + "  Ask: " + $ask + "  Spread: " + $spread + 
"\n" +~0D~0A           "Planned Entry: " + $pxEntry
 + "  Planned Stop: " + $hypoStop + "\n\n";~0D~0A  
  if ($stopVsBidFail == 1)  { $msg = $msg + "- STOP
_ABOVE_BID_WITH_MARGIN\n"; }~0D~0A    if ($spreadTo
oWide == 1)  { $msg = $msg + "- SPREAD_TOO_WIDE vs 
stopOff\n"; }~0D~0A    MsgBox($msg + "\nAction abor
ted.");~0D~0A    return;~0D~0A}~0D~0A~0D~0A// Per-t
rade risk cap (projected risk = stopLossTrigger * a
ddShares)~0D~0Aif ($usePerTradeRiskCap == 1) {~0D~0A
    $projRisk = $stopLossTrigger * $addShares;~0D~0A
    if ($projRisk > $riskCapDollars) {~0D~0A       
 MsgBox("Risk cap exceeded for " + Symbol + ": proj
ected $" + $projRisk + " > cap $" + $riskCapDollars
 + ". Aborting.");~0D~0A        return;~0D~0A    }~0D
~0A}~0D~0A~0D~0A// === 2) Cancel only BUY working o
rders (keep existing protection until we actually f
ill) ===~0D~0A$acc = GetAccountObj(Account);~0D~0A$
acc.CancelOrder("BUY", Symbol, 0);~0D~0A~0D~0A// ==
= 3) Build entry; snap entry to increment to reduce
 rejects ===~0D~0A// Re-evaluate inc using pxEntry 
(some symbols jump bands)~0D~0A$inc = 0.01;~0D~0Aif
 ($pxEntry < 1 || $bid < 1 || $ask < 1) { $inc = 0.
001; }~0D~0Aif ($pxEntry < 0.25 || $bid < 0.25 || $
ask < 0.25) { $inc = 0.0005; }~0D~0A$pxEntry = Roun
d($pxEntry, 102, $inc);~0D~0A~0D~0A$order = NewOrde
rObj();~0D~0A$order.Account = Account;~0D~0A$order.
Symbol  = Symbol;~0D~0A$order.Route   = "ARCA";~0D~0A
$order.Tif     = "DAY+";~0D~0A$order.Side    = "B";
      // Buy~0D~0A$order.Type    = "L";      // Lim
it~0D~0A$order.Price   = $pxEntry;~0D~0A$order.Shar
e   = $addShares;~0D~0A$order.Send();~0D~0A~0D~0A~0D
~0A// === 4) Poll for fill (break when criteria met
) ===~0D~0A$i            = 0;~0D~0A$filled      = 0
;~0D~0A$filledQty = 0;~0D~0Awhile ($i < $maxPolls &
& $filled == 0) {~0D~0A    Wait($pollMs);~0D~0A    
$order.GetInfo();                        // refresh
 order object~0D~0A    $filledQty = $order.Share - 
$order.Open; // how many filled so far~0D~0A    if 
($order.Open == 0) {~0D~0A        $filled = 1; // f
ull fill~0D~0A        break;~0D~0A    }~0D~0A    if
 ($acceptPartial == 1 && $filledQty >= $minFillShar
es) {~0D~0A        $filled = 2; // partial-accepted
~0D~0A        break;~0D~0A    }~0D~0A    $i = $i + 
1;~0D~0A}~0D~0A~0D~0A// throttle between orders~0D~0A
$elapsed = $i * $pollMs;~0D~0Aif ($elapsed < $minDe
layMs) {~0D~0A    Wait($minDelayMs - $elapsed);~0D~0A
}~0D~0A~0D~0A// === 5) If no acceptable fill, cance
l and exit (do not touch existing stops) ===~0D~0Ai
f ($filled == 0) {~0D~0A    $order.Cancel();~0D~0A 
   return;~0D~0A}~0D~0A~0D~0A// Optional: if we acc
epted a partial and want to freeze size before armi
ng stop~0D~0Aif ($filled == 2 && $cancelRemainderOn
Partial == 1) {~0D~0A    $order.Cancel();~0D~0A    
// brief wait to let the residual cancel~0D~0A    W
ait(200);~0D~0A}~0D~0A~0D~0A// === 6) Arm unified 1
R stop via reusable ~E2~80~9CSet Auto Stop~E2~80~9D
 script ===~0D~0Aif ($useAutoStop == "Yes") {~0D~0A
    ExecHotKey("Set Auto Stop");   ~0D~0A}~0D~0A~0D
~0A// == 7) Build and set take profit trigger (opti
onal) ==~0D~0A// Only (re)build TP if we are NOT al
ready profitable on the existing position.~0D~0A// 
For longs, "profitable" means: BID > avgBefore on t
he position that existed~0D~0A// before this entry.
 If we're already green, do NOT reset TP.~0D~0Aif (
$useTakeProfit == "Yes") {~0D~0A~0D~0A    // If no 
position beforehand, always set TP (fresh trade)~0D
~0A    if ($posBefore <= 0) {~0D~0A        ExecHotK
ey("Set Take Profit");~0D~0A    } else {~0D~0A     
   // We had a long position before this add. Check
 profitability.~0D~0A        $bidNow = BID;~0D~0A~0D
~0A        // If avgBefore is invalid, be conservat
ive and allow TP reset~0D~0A        if ($avgBefore 
<= 0) {~0D~0A            ExecHotKey("Set Take Profi
t");~0D~0A        } else {~0D~0A            // Only
 reset TP if NOT yet profitable (bid <= avgBefore)~0D
~0A            if ($bidNow <= $avgBefore) {~0D~0A  
              ExecHotKey("Set Take Profit");~0D~0A 
           }~0D~0A            // else: already prof
itable ~E2~86~92 do nothing, keep existing TP~0D~0A
        }~0D~0A    }~0D~0A}~0D~0A~0D~0A// --- End -
--
Alt+Ctrl+Shift+2:Buy 50 Ask+ SL:~ 7452:// =====================~0D~0A//  SCALING-AWARE ENT
RY~0D~0A// =====================~0D~0A~0D~0A// Chec
k rehab flag first~0D~0Aif ($rehab == 1 && $ACCOUNT
_STATE == "live") { MsgBox("ABORTED: Rehabe share s
ize viloation!"); return; }~0D~0A~0D~0AFocusWindow 
Primary_OE;~0D~0A~0D~0A// ---- Global daily-loss gu
ard per account ----~0D~0A$accName = GetVar("DAY_AC
C");~0D~0A$lockKey = "TRADING_LOCKED_" + $accName;~0D
~0A$locked  = GetVar($lockKey) * 1;~0D~0A~0D~0Aif (
$locked == 1) {~0D~0A    MsgBox("Trading locked for
 " + $accName + " (daily loss limit hit).");~0D~0A 
   return;~0D~0A}~0D~0A~0D~0A// Set ENTRY_SYM and c
lear TP_SYMBOL~0D~0A$M = GetWindowObj("Primary_OE")
;~0D~0Aif (IsObj($M)) {~0D~0A    $entrySymbol = $M.
Symb;~0D~0A} else {~0D~0A    $entrySymbol = Symbol;
~0D~0A}~0D~0A$tpSymbol = "";~0D~0A~0D~0A// --- Capt
ure pre-entry position & average cost (for TP logic
) ---~0D~0A$posBefore = 0;~0D~0A$avgBefore = 0;~0D~0A
~0D~0Aif (IsObj($M)) {~0D~0A    $posBefore = $M.Pos
;~0D~0A    $avgBefore = $M.AvgCost;~0D~0A} else {~0D
~0A    $posBefore = Pos;~0D~0A    $avgBefore = AvgC
ost;~0D~0A}~0D~0A~0D~0A// ---- Tunables ----~0D~0A$
addShares     = 50 * $qtyMult;~0D~0A$refPx         
    = ASK;             // BID or ASK~0D~0A$minDelay
Ms  = 1000;           // throttle between order sen
ds (ms)~0D~0A~0D~0A// ---- Max position size guard 
rail ----~0D~0Aif ($maxPositionSize > 0) {    ~0D~0A
    // Determine current position in Primary_OE (fa
llback: Pos)~0D~0A    $curPos = 0;~0D~0A    if (IsO
bj($M)) {~0D~0A        $curPos = $M.Pos;~0D~0A    }
 else {~0D~0A        $curPos = Pos;        // DAS b
uilt-in position for current symbol~0D~0A    }~0D~0A
~0D~0A    // Remaining capacity before hitting the 
guard rail~0D~0A    $remaining = $maxPositionSize -
 $curPos;~0D~0A~0D~0A    // If we're already at / a
bove max, do not allow more size~0D~0A    if ($rema
ining <= 0) {~0D~0A        MsgBox("Max position siz
e reached for " + Symbol + ~0D~0A               " (
" + $maxPositionSize + " shares). No additional siz
e allowed.");~0D~0A        return;~0D~0A    }~0D~0A
~0D~0A    // If this clip would exceed max size, cl
amp it down~0D~0A    if ($addShares > $remaining) {
~0D~0A        $addShares = $remaining;~0D~0A    }~0D
~0A~0D~0A}~0D~0A~0D~0A// ---- Tick-size Bands (no f
unctions; simple if-else ladder) ----~0D~0A// We~E2
~80~99ll resolve the increment later using current 
prices.~0D~0A//   < $0.25  -> 0.0005~0D~0A//   < $1
.00  -> 0.001~0D~0A//   ~E2~89~A5 $1.00  -> 0.01~0D
~0A~0D~0A// === 0) Quote sanity & derived prices fo
r safety check ===~0D~0A$bid    = BID;~0D~0A$ask   
 = ASK;~0D~0A$spread = $ask - $bid;~0D~0A~0D~0Aif (
$bid <= 0 || $ask <= 0 || $spread < 0) {~0D~0A    M
sgBox("Quote sanity failed for " + Symbol + ": BID=
" + $bid + " ASK=" + $ask + ". Aborting.");~0D~0A  
  return;~0D~0A}~0D~0A~0D~0A// Projected entry/stop
 based on reference side~0D~0A$pxEntry    = $refPx 
+ $entryOffset;~0D~0A$hypoStop = $pxEntry - $stopLo
ssTrigger;~0D~0A~0D~0A// ---- Resolve tick incremen
t for safety checks (based on current context) ----
~0D~0A$inc = 0.01;~0D~0Aif ($pxEntry < 1 || $hypoSt
op < 1 || $bid < 1 || $ask < 1)        { $inc = 0.0
01; }~0D~0Aif ($pxEntry < 0.25 || $hypoStop < 0.25 
|| $bid < 0.25 || $ask < 0.25) { $inc = 0.0005; }~0D
~0A~0D~0A// === 1) Slippage-aware spread/stop safet
y (longs) ===~0D~0A$stopVsBidFail = 0;~0D~0A~0D~0A/
/ margin for safety = max(slipTicksMin * inc, slipS
preadFrac * spread)~0D~0A$slipMargin         = ($sl
ipTicksMin * $inc);~0D~0A$slipSpreadPart  = ($slipS
preadFrac * $spread);~0D~0Aif ($slipSpreadPart > $s
lipMargin) { $slipMargin = $slipSpreadPart; }~0D~0A
~0D~0Aif ($useSlippageMargin == 1) {~0D~0A    // Re
quire stop to be below (Bid + margin)~0D~0A    if (
$hypoStop >= ($bid + $slipMargin)) { $stopVsBidFail
 = 1; }~0D~0A} else {~0D~0A    if ($hypoStop >= $bi
d) { $stopVsBidFail = 1; }~0D~0A}~0D~0A~0D~0A// spr
ead relative to stop distance guard (tune threshold
 as desired)~0D~0A$spreadTooWide = ($spread > ($sto
pLossTrigger * 0.75)) && $useSpreadCheck == 1;~0D~0A
~0D~0A// If either fails, alert and abort unless we
 are adding to an existing position~0D~0Aif (($stop
VsBidFail == 1 || $spreadTooWide == 1) && $posBefor
e <=0) {~0D~0A    $msg = "Spread/Stop safety failed
 for " + Symbol + "\n" +~0D~0A           "Bid: " + 
$bid + "  Ask: " + $ask + "  Spread: " + $spread + 
"\n" +~0D~0A           "Planned Entry: " + $pxEntry
 + "  Planned Stop: " + $hypoStop + "\n\n";~0D~0A  
  if ($stopVsBidFail == 1)  { $msg = $msg + "- STOP
_ABOVE_BID_WITH_MARGIN\n"; }~0D~0A    if ($spreadTo
oWide == 1)  { $msg = $msg + "- SPREAD_TOO_WIDE vs 
stopOff\n"; }~0D~0A    MsgBox($msg + "\nAction abor
ted.");~0D~0A    return;~0D~0A}~0D~0A~0D~0A// Per-t
rade risk cap (projected risk = stopLossTrigger * a
ddShares)~0D~0Aif ($usePerTradeRiskCap == 1) {~0D~0A
    $projRisk = $stopLossTrigger * $addShares;~0D~0A
    if ($projRisk > $riskCapDollars) {~0D~0A       
 MsgBox("Risk cap exceeded for " + Symbol + ": proj
ected $" + $projRisk + " > cap $" + $riskCapDollars
 + ". Aborting.");~0D~0A        return;~0D~0A    }~0D
~0A}~0D~0A~0D~0A// === 2) Cancel only BUY working o
rders (keep existing protection until we actually f
ill) ===~0D~0A$acc = GetAccountObj(Account);~0D~0A$
acc.CancelOrder("BUY", Symbol, 0);~0D~0A~0D~0A// ==
= 3) Build entry; snap entry to increment to reduce
 rejects ===~0D~0A// Re-evaluate inc using pxEntry 
(some symbols jump bands)~0D~0A$inc = 0.01;~0D~0Aif
 ($pxEntry < 1 || $bid < 1 || $ask < 1) { $inc = 0.
001; }~0D~0Aif ($pxEntry < 0.25 || $bid < 0.25 || $
ask < 0.25) { $inc = 0.0005; }~0D~0A$pxEntry = Roun
d($pxEntry, 102, $inc);~0D~0A~0D~0A$order = NewOrde
rObj();~0D~0A$order.Account = Account;~0D~0A$order.
Symbol  = Symbol;~0D~0A$order.Route   = "ARCA";~0D~0A
$order.Tif     = "DAY+";~0D~0A$order.Side    = "B";
      // Buy~0D~0A$order.Type    = "L";      // Lim
it~0D~0A$order.Price   = $pxEntry;~0D~0A$order.Shar
e   = $addShares;~0D~0A$order.Send();~0D~0A~0D~0A~0D
~0A// === 4) Poll for fill (break when criteria met
) ===~0D~0A$i            = 0;~0D~0A$filled      = 0
;~0D~0A$filledQty = 0;~0D~0Awhile ($i < $maxPolls &
& $filled == 0) {~0D~0A    Wait($pollMs);~0D~0A    
$order.GetInfo();                        // refresh
 order object~0D~0A    $filledQty = $order.Share - 
$order.Open; // how many filled so far~0D~0A    if 
($order.Open == 0) {~0D~0A        $filled = 1; // f
ull fill~0D~0A        break;~0D~0A    }~0D~0A    if
 ($acceptPartial == 1 && $filledQty >= $minFillShar
es) {~0D~0A        $filled = 2; // partial-accepted
~0D~0A        break;~0D~0A    }~0D~0A    $i = $i + 
1;~0D~0A}~0D~0A~0D~0A// throttle between orders~0D~0A
$elapsed = $i * $pollMs;~0D~0Aif ($elapsed < $minDe
layMs) {~0D~0A    Wait($minDelayMs - $elapsed);~0D~0A
}~0D~0A~0D~0A// === 5) If no acceptable fill, cance
l and exit (do not touch existing stops) ===~0D~0Ai
f ($filled == 0) {~0D~0A    $order.Cancel();~0D~0A 
   return;~0D~0A}~0D~0A~0D~0A// Optional: if we acc
epted a partial and want to freeze size before armi
ng stop~0D~0Aif ($filled == 2 && $cancelRemainderOn
Partial == 1) {~0D~0A    $order.Cancel();~0D~0A    
// brief wait to let the residual cancel~0D~0A    W
ait(200);~0D~0A}~0D~0A~0D~0A// === 6) Arm unified 1
R stop via reusable ~E2~80~9CSet Auto Stop~E2~80~9D
 script ===~0D~0Aif ($useAutoStop == "Yes") {~0D~0A
    ExecHotKey("Set Auto Stop");   ~0D~0A}~0D~0A~0D
~0A// == 7) Build and set take profit trigger (opti
onal) ==~0D~0A// Only (re)build TP if we are NOT al
ready profitable on the existing position.~0D~0A// 
For longs, "profitable" means: BID > avgBefore on t
he position that existed~0D~0A// before this entry.
 If we're already green, do NOT reset TP.~0D~0Aif (
$useTakeProfit == "Yes") {~0D~0A~0D~0A    // If no 
position beforehand, always set TP (fresh trade)~0D
~0A    if ($posBefore <= 0) {~0D~0A        ExecHotK
ey("Set Take Profit");~0D~0A    } else {~0D~0A     
   // We had a long position before this add. Check
 profitability.~0D~0A        $bidNow = BID;~0D~0A~0D
~0A        // If avgBefore is invalid, be conservat
ive and allow TP reset~0D~0A        if ($avgBefore 
<= 0) {~0D~0A            ExecHotKey("Set Take Profi
t");~0D~0A        } else {~0D~0A            // Only
 reset TP if NOT yet profitable (bid <= avgBefore)~0D
~0A            if ($bidNow <= $avgBefore) {~0D~0A  
              ExecHotKey("Set Take Profit");~0D~0A 
           }~0D~0A            // else: already prof
itable ~E2~86~92 do nothing, keep existing TP~0D~0A
        }~0D~0A    }~0D~0A}~0D~0A~0D~0A// --- End -
--
Alt+Ctrl+Shift+3:Buy 100 Ask+ SL:~ 7453:// =====================~0D~0A//  SCALING-AWARE ENT
RY~0D~0A// =====================~0D~0A~0D~0A// Chec
k rehab flag first~0D~0Aif ($rehab == 1 && $ACCOUNT
_STATE == "live") { MsgBox("ABORTED: Rehabe share s
ize viloation!"); return; }~0D~0A~0D~0AFocusWindow 
Primary_OE;~0D~0A~0D~0A// ---- Global daily-loss gu
ard per account ----~0D~0A$accName = GetVar("DAY_AC
C");~0D~0A$lockKey = "TRADING_LOCKED_" + $accName;~0D
~0A$locked  = GetVar($lockKey) * 1;~0D~0A~0D~0Aif (
$locked == 1) {~0D~0A    MsgBox("Trading locked for
 " + $accName + " (daily loss limit hit).");~0D~0A 
   return;~0D~0A}~0D~0A~0D~0A// Set ENTRY_SYM and c
lear TP_SYMBOL~0D~0A$M = GetWindowObj("Primary_OE")
;~0D~0Aif (IsObj($M)) {~0D~0A    $entrySymbol = $M.
Symb;~0D~0A} else {~0D~0A    $entrySymbol = Symbol;
~0D~0A}~0D~0A$tpSymbol = "";~0D~0A~0D~0A// --- Capt
ure pre-entry position & average cost (for TP logic
) ---~0D~0A$posBefore = 0;~0D~0A$avgBefore = 0;~0D~0A
~0D~0Aif (IsObj($M)) {~0D~0A    $posBefore = $M.Pos
;~0D~0A    $avgBefore = $M.AvgCost;~0D~0A} else {~0D
~0A    $posBefore = Pos;~0D~0A    $avgBefore = AvgC
ost;~0D~0A}~0D~0A~0D~0A// ---- Tunables ----~0D~0A$
addShares     = 100 * $qtyMult;~0D~0A$refPx        
     = ASK;             // BID or ASK~0D~0A$minDela
yMs  = 1000;           // throttle between order se
nds (ms)~0D~0A~0D~0A// ---- Max position size guard
 rail ----~0D~0Aif ($maxPositionSize > 0) {    ~0D~0A
    // Determine current position in Primary_OE (fa
llback: Pos)~0D~0A    $curPos = 0;~0D~0A    if (IsO
bj($M)) {~0D~0A        $curPos = $M.Pos;~0D~0A    }
 else {~0D~0A        $curPos = Pos;        // DAS b
uilt-in position for current symbol~0D~0A    }~0D~0A
~0D~0A    // Remaining capacity before hitting the 
guard rail~0D~0A    $remaining = $maxPositionSize -
 $curPos;~0D~0A~0D~0A    // If we're already at / a
bove max, do not allow more size~0D~0A    if ($rema
ining <= 0) {~0D~0A        MsgBox("Max position siz
e reached for " + Symbol + ~0D~0A               " (
" + $maxPositionSize + " shares). No additional siz
e allowed.");~0D~0A        return;~0D~0A    }~0D~0A
~0D~0A    // If this clip would exceed max size, cl
amp it down~0D~0A    if ($addShares > $remaining) {
~0D~0A        $addShares = $remaining;~0D~0A    }~0D
~0A~0D~0A}~0D~0A~0D~0A// ---- Tick-size Bands (no f
unctions; simple if-else ladder) ----~0D~0A// We~E2
~80~99ll resolve the increment later using current 
prices.~0D~0A//   < $0.25  -> 0.0005~0D~0A//   < $1
.00  -> 0.001~0D~0A//   ~E2~89~A5 $1.00  -> 0.01~0D
~0A~0D~0A// === 0) Quote sanity & derived prices fo
r safety check ===~0D~0A$bid    = BID;~0D~0A$ask   
 = ASK;~0D~0A$spread = $ask - $bid;~0D~0A~0D~0Aif (
$bid <= 0 || $ask <= 0 || $spread < 0) {~0D~0A    M
sgBox("Quote sanity failed for " + Symbol + ": BID=
" + $bid + " ASK=" + $ask + ". Aborting.");~0D~0A  
  return;~0D~0A}~0D~0A~0D~0A// Projected entry/stop
 based on reference side~0D~0A$pxEntry    = $refPx 
+ $entryOffset;~0D~0A$hypoStop = $pxEntry - $stopLo
ssTrigger;~0D~0A~0D~0A// ---- Resolve tick incremen
t for safety checks (based on current context) ----
~0D~0A$inc = 0.01;~0D~0Aif ($pxEntry < 1 || $hypoSt
op < 1 || $bid < 1 || $ask < 1)        { $inc = 0.0
01; }~0D~0Aif ($pxEntry < 0.25 || $hypoStop < 0.25 
|| $bid < 0.25 || $ask < 0.25) { $inc = 0.0005; }~0D
~0A~0D~0A// === 1) Slippage-aware spread/stop safet
y (longs) ===~0D~0A$stopVsBidFail = 0;~0D~0A~0D~0A/
/ margin for safety = max(slipTicksMin * inc, slipS
preadFrac * spread)~0D~0A$slipMargin         = ($sl
ipTicksMin * $inc);~0D~0A$slipSpreadPart  = ($slipS
preadFrac * $spread);~0D~0Aif ($slipSpreadPart > $s
lipMargin) { $slipMargin = $slipSpreadPart; }~0D~0A
~0D~0Aif ($useSlippageMargin == 1) {~0D~0A    // Re
quire stop to be below (Bid + margin)~0D~0A    if (
$hypoStop >= ($bid + $slipMargin)) { $stopVsBidFail
 = 1; }~0D~0A} else {~0D~0A    if ($hypoStop >= $bi
d) { $stopVsBidFail = 1; }~0D~0A}~0D~0A~0D~0A// spr
ead relative to stop distance guard (tune threshold
 as desired)~0D~0A$spreadTooWide = ($spread > ($sto
pLossTrigger * 0.75)) && $useSpreadCheck == 1;~0D~0A
~0D~0A// If either fails, alert and abort unless we
 are adding to an existing position~0D~0Aif (($stop
VsBidFail == 1 || $spreadTooWide == 1) && $posBefor
e <=0) {~0D~0A    $msg = "Spread/Stop safety failed
 for " + Symbol + "\n" +~0D~0A           "Bid: " + 
$bid + "  Ask: " + $ask + "  Spread: " + $spread + 
"\n" +~0D~0A           "Planned Entry: " + $pxEntry
 + "  Planned Stop: " + $hypoStop + "\n\n";~0D~0A  
  if ($stopVsBidFail == 1)  { $msg = $msg + "- STOP
_ABOVE_BID_WITH_MARGIN\n"; }~0D~0A    if ($spreadTo
oWide == 1)  { $msg = $msg + "- SPREAD_TOO_WIDE vs 
stopOff\n"; }~0D~0A    MsgBox($msg + "\nAction abor
ted.");~0D~0A    return;~0D~0A}~0D~0A~0D~0A// Per-t
rade risk cap (projected risk = stopLossTrigger * a
ddShares)~0D~0Aif ($usePerTradeRiskCap == 1) {~0D~0A
    $projRisk = $stopLossTrigger * $addShares;~0D~0A
    if ($projRisk > $riskCapDollars) {~0D~0A       
 MsgBox("Risk cap exceeded for " + Symbol + ": proj
ected $" + $projRisk + " > cap $" + $riskCapDollars
 + ". Aborting.");~0D~0A        return;~0D~0A    }~0D
~0A}~0D~0A~0D~0A// === 2) Cancel only BUY working o
rders (keep existing protection until we actually f
ill) ===~0D~0A$acc = GetAccountObj(Account);~0D~0A$
acc.CancelOrder("BUY", Symbol, 0);~0D~0A~0D~0A// ==
= 3) Build entry; snap entry to increment to reduce
 rejects ===~0D~0A// Re-evaluate inc using pxEntry 
(some symbols jump bands)~0D~0A$inc = 0.01;~0D~0Aif
 ($pxEntry < 1 || $bid < 1 || $ask < 1) { $inc = 0.
001; }~0D~0Aif ($pxEntry < 0.25 || $bid < 0.25 || $
ask < 0.25) { $inc = 0.0005; }~0D~0A$pxEntry = Roun
d($pxEntry, 102, $inc);~0D~0A~0D~0A$order = NewOrde
rObj();~0D~0A$order.Account = Account;~0D~0A$order.
Symbol  = Symbol;~0D~0A$order.Route   = "ARCA";~0D~0A
$order.Tif     = "DAY+";~0D~0A$order.Side    = "B";
      // Buy~0D~0A$order.Type    = "L";      // Lim
it~0D~0A$order.Price   = $pxEntry;~0D~0A$order.Shar
e   = $addShares;~0D~0A$order.Send();~0D~0A~0D~0A~0D
~0A// === 4) Poll for fill (break when criteria met
) ===~0D~0A$i            = 0;~0D~0A$filled      = 0
;~0D~0A$filledQty = 0;~0D~0Awhile ($i < $maxPolls &
& $filled == 0) {~0D~0A    Wait($pollMs);~0D~0A    
$order.GetInfo();                        // refresh
 order object~0D~0A    $filledQty = $order.Share - 
$order.Open; // how many filled so far~0D~0A    if 
($order.Open == 0) {~0D~0A        $filled = 1; // f
ull fill~0D~0A        break;~0D~0A    }~0D~0A    if
 ($acceptPartial == 1 && $filledQty >= $minFillShar
es) {~0D~0A        $filled = 2; // partial-accepted
~0D~0A        break;~0D~0A    }~0D~0A    $i = $i + 
1;~0D~0A}~0D~0A~0D~0A// throttle between orders~0D~0A
$elapsed = $i * $pollMs;~0D~0Aif ($elapsed < $minDe
layMs) {~0D~0A    Wait($minDelayMs - $elapsed);~0D~0A
}~0D~0A~0D~0A// === 5) If no acceptable fill, cance
l and exit (do not touch existing stops) ===~0D~0Ai
f ($filled == 0) {~0D~0A    $order.Cancel();~0D~0A 
   return;~0D~0A}~0D~0A~0D~0A// Optional: if we acc
epted a partial and want to freeze size before armi
ng stop~0D~0Aif ($filled == 2 && $cancelRemainderOn
Partial == 1) {~0D~0A    $order.Cancel();~0D~0A    
// brief wait to let the residual cancel~0D~0A    W
ait(200);~0D~0A}~0D~0A~0D~0A// === 6) Arm unified 1
R stop via reusable ~E2~80~9CSet Auto Stop~E2~80~9D
 script ===~0D~0Aif ($useAutoStop == "Yes") {~0D~0A
    ExecHotKey("Set Auto Stop");   ~0D~0A}~0D~0A~0D
~0A// == 7) Build and set take profit trigger (opti
onal) ==~0D~0A// Only (re)build TP if we are NOT al
ready profitable on the existing position.~0D~0A// 
For longs, "profitable" means: BID > avgBefore on t
he position that existed~0D~0A// before this entry.
 If we're already green, do NOT reset TP.~0D~0Aif (
$useTakeProfit == "Yes") {~0D~0A~0D~0A    // If no 
position beforehand, always set TP (fresh trade)~0D
~0A    if ($posBefore <= 0) {~0D~0A        ExecHotK
ey("Set Take Profit");~0D~0A    } else {~0D~0A     
   // We had a long position before this add. Check
 profitability.~0D~0A        $bidNow = BID;~0D~0A~0D
~0A        // If avgBefore is invalid, be conservat
ive and allow TP reset~0D~0A        if ($avgBefore 
<= 0) {~0D~0A            ExecHotKey("Set Take Profi
t");~0D~0A        } else {~0D~0A            // Only
 reset TP if NOT yet profitable (bid <= avgBefore)~0D
~0A            if ($bidNow <= $avgBefore) {~0D~0A  
              ExecHotKey("Set Take Profit");~0D~0A 
           }~0D~0A            // else: already prof
itable ~E2~86~92 do nothing, keep existing TP~0D~0A
        }~0D~0A    }~0D~0A}~0D~0A~0D~0A// --- End -
--
Alt+Ctrl+Shift+4:Buy 150 Ask+ SL:~ 7453:// =====================~0D~0A//  SCALING-AWARE ENT
RY~0D~0A// =====================~0D~0A~0D~0A// Chec
k rehab flag first~0D~0Aif ($rehab == 1 && $ACCOUNT
_STATE == "live") { MsgBox("ABORTED: Rehabe share s
ize viloation!"); return; }~0D~0A~0D~0AFocusWindow 
Primary_OE;~0D~0A~0D~0A// ---- Global daily-loss gu
ard per account ----~0D~0A$accName = GetVar("DAY_AC
C");~0D~0A$lockKey = "TRADING_LOCKED_" + $accName;~0D
~0A$locked  = GetVar($lockKey) * 1;~0D~0A~0D~0Aif (
$locked == 1) {~0D~0A    MsgBox("Trading locked for
 " + $accName + " (daily loss limit hit).");~0D~0A 
   return;~0D~0A}~0D~0A~0D~0A// Set ENTRY_SYM and c
lear TP_SYMBOL~0D~0A$M = GetWindowObj("Primary_OE")
;~0D~0Aif (IsObj($M)) {~0D~0A    $entrySymbol = $M.
Symb;~0D~0A} else {~0D~0A    $entrySymbol = Symbol;
~0D~0A}~0D~0A$tpSymbol = "";~0D~0A~0D~0A// --- Capt
ure pre-entry position & average cost (for TP logic
) ---~0D~0A$posBefore = 0;~0D~0A$avgBefore = 0;~0D~0A
~0D~0Aif (IsObj($M)) {~0D~0A    $posBefore = $M.Pos
;~0D~0A    $avgBefore = $M.AvgCost;~0D~0A} else {~0D
~0A    $posBefore = Pos;~0D~0A    $avgBefore = AvgC
ost;~0D~0A}~0D~0A~0D~0A// ---- Tunables ----~0D~0A$
addShares     = 150 * $qtyMult;~0D~0A$refPx        
     = ASK;             // BID or ASK~0D~0A$minDela
yMs  = 1000;           // throttle between order se
nds (ms)~0D~0A~0D~0A// ---- Max position size guard
 rail ----~0D~0Aif ($maxPositionSize > 0) {    ~0D~0A
    // Determine current position in Primary_OE (fa
llback: Pos)~0D~0A    $curPos = 0;~0D~0A    if (IsO
bj($M)) {~0D~0A        $curPos = $M.Pos;~0D~0A    }
 else {~0D~0A        $curPos = Pos;        // DAS b
uilt-in position for current symbol~0D~0A    }~0D~0A
~0D~0A    // Remaining capacity before hitting the 
guard rail~0D~0A    $remaining = $maxPositionSize -
 $curPos;~0D~0A~0D~0A    // If we're already at / a
bove max, do not allow more size~0D~0A    if ($rema
ining <= 0) {~0D~0A        MsgBox("Max position siz
e reached for " + Symbol + ~0D~0A               " (
" + $maxPositionSize + " shares). No additional siz
e allowed.");~0D~0A        return;~0D~0A    }~0D~0A
~0D~0A    // If this clip would exceed max size, cl
amp it down~0D~0A    if ($addShares > $remaining) {
~0D~0A        $addShares = $remaining;~0D~0A    }~0D
~0A~0D~0A}~0D~0A~0D~0A// ---- Tick-size Bands (no f
unctions; simple if-else ladder) ----~0D~0A// We~E2
~80~99ll resolve the increment later using current 
prices.~0D~0A//   < $0.25  -> 0.0005~0D~0A//   < $1
.00  -> 0.001~0D~0A//   ~E2~89~A5 $1.00  -> 0.01~0D
~0A~0D~0A// === 0) Quote sanity & derived prices fo
r safety check ===~0D~0A$bid    = BID;~0D~0A$ask   
 = ASK;~0D~0A$spread = $ask - $bid;~0D~0A~0D~0Aif (
$bid <= 0 || $ask <= 0 || $spread < 0) {~0D~0A    M
sgBox("Quote sanity failed for " + Symbol + ": BID=
" + $bid + " ASK=" + $ask + ". Aborting.");~0D~0A  
  return;~0D~0A}~0D~0A~0D~0A// Projected entry/stop
 based on reference side~0D~0A$pxEntry    = $refPx 
+ $entryOffset;~0D~0A$hypoStop = $pxEntry - $stopLo
ssTrigger;~0D~0A~0D~0A// ---- Resolve tick incremen
t for safety checks (based on current context) ----
~0D~0A$inc = 0.01;~0D~0Aif ($pxEntry < 1 || $hypoSt
op < 1 || $bid < 1 || $ask < 1)        { $inc = 0.0
01; }~0D~0Aif ($pxEntry < 0.25 || $hypoStop < 0.25 
|| $bid < 0.25 || $ask < 0.25) { $inc = 0.0005; }~0D
~0A~0D~0A// === 1) Slippage-aware spread/stop safet
y (longs) ===~0D~0A$stopVsBidFail = 0;~0D~0A~0D~0A/
/ margin for safety = max(slipTicksMin * inc, slipS
preadFrac * spread)~0D~0A$slipMargin         = ($sl
ipTicksMin * $inc);~0D~0A$slipSpreadPart  = ($slipS
preadFrac * $spread);~0D~0Aif ($slipSpreadPart > $s
lipMargin) { $slipMargin = $slipSpreadPart; }~0D~0A
~0D~0Aif ($useSlippageMargin == 1) {~0D~0A    // Re
quire stop to be below (Bid + margin)~0D~0A    if (
$hypoStop >= ($bid + $slipMargin)) { $stopVsBidFail
 = 1; }~0D~0A} else {~0D~0A    if ($hypoStop >= $bi
d) { $stopVsBidFail = 1; }~0D~0A}~0D~0A~0D~0A// spr
ead relative to stop distance guard (tune threshold
 as desired)~0D~0A$spreadTooWide = ($spread > ($sto
pLossTrigger * 0.75)) && $useSpreadCheck == 1;~0D~0A
~0D~0A// If either fails, alert and abort unless we
 are adding to an existing position~0D~0Aif (($stop
VsBidFail == 1 || $spreadTooWide == 1) && $posBefor
e <=0) {~0D~0A    $msg = "Spread/Stop safety failed
 for " + Symbol + "\n" +~0D~0A           "Bid: " + 
$bid + "  Ask: " + $ask + "  Spread: " + $spread + 
"\n" +~0D~0A           "Planned Entry: " + $pxEntry
 + "  Planned Stop: " + $hypoStop + "\n\n";~0D~0A  
  if ($stopVsBidFail == 1)  { $msg = $msg + "- STOP
_ABOVE_BID_WITH_MARGIN\n"; }~0D~0A    if ($spreadTo
oWide == 1)  { $msg = $msg + "- SPREAD_TOO_WIDE vs 
stopOff\n"; }~0D~0A    MsgBox($msg + "\nAction abor
ted.");~0D~0A    return;~0D~0A}~0D~0A~0D~0A// Per-t
rade risk cap (projected risk = stopLossTrigger * a
ddShares)~0D~0Aif ($usePerTradeRiskCap == 1) {~0D~0A
    $projRisk = $stopLossTrigger * $addShares;~0D~0A
    if ($projRisk > $riskCapDollars) {~0D~0A       
 MsgBox("Risk cap exceeded for " + Symbol + ": proj
ected $" + $projRisk + " > cap $" + $riskCapDollars
 + ". Aborting.");~0D~0A        return;~0D~0A    }~0D
~0A}~0D~0A~0D~0A// === 2) Cancel only BUY working o
rders (keep existing protection until we actually f
ill) ===~0D~0A$acc = GetAccountObj(Account);~0D~0A$
acc.CancelOrder("BUY", Symbol, 0);~0D~0A~0D~0A// ==
= 3) Build entry; snap entry to increment to reduce
 rejects ===~0D~0A// Re-evaluate inc using pxEntry 
(some symbols jump bands)~0D~0A$inc = 0.01;~0D~0Aif
 ($pxEntry < 1 || $bid < 1 || $ask < 1) { $inc = 0.
001; }~0D~0Aif ($pxEntry < 0.25 || $bid < 0.25 || $
ask < 0.25) { $inc = 0.0005; }~0D~0A$pxEntry = Roun
d($pxEntry, 102, $inc);~0D~0A~0D~0A$order = NewOrde
rObj();~0D~0A$order.Account = Account;~0D~0A$order.
Symbol  = Symbol;~0D~0A$order.Route   = "ARCA";~0D~0A
$order.Tif     = "DAY+";~0D~0A$order.Side    = "B";
      // Buy~0D~0A$order.Type    = "L";      // Lim
it~0D~0A$order.Price   = $pxEntry;~0D~0A$order.Shar
e   = $addShares;~0D~0A$order.Send();~0D~0A~0D~0A~0D
~0A// === 4) Poll for fill (break when criteria met
) ===~0D~0A$i            = 0;~0D~0A$filled      = 0
;~0D~0A$filledQty = 0;~0D~0Awhile ($i < $maxPolls &
& $filled == 0) {~0D~0A    Wait($pollMs);~0D~0A    
$order.GetInfo();                        // refresh
 order object~0D~0A    $filledQty = $order.Share - 
$order.Open; // how many filled so far~0D~0A    if 
($order.Open == 0) {~0D~0A        $filled = 1; // f
ull fill~0D~0A        break;~0D~0A    }~0D~0A    if
 ($acceptPartial == 1 && $filledQty >= $minFillShar
es) {~0D~0A        $filled = 2; // partial-accepted
~0D~0A        break;~0D~0A    }~0D~0A    $i = $i + 
1;~0D~0A}~0D~0A~0D~0A// throttle between orders~0D~0A
$elapsed = $i * $pollMs;~0D~0Aif ($elapsed < $minDe
layMs) {~0D~0A    Wait($minDelayMs - $elapsed);~0D~0A
}~0D~0A~0D~0A// === 5) If no acceptable fill, cance
l and exit (do not touch existing stops) ===~0D~0Ai
f ($filled == 0) {~0D~0A    $order.Cancel();~0D~0A 
   return;~0D~0A}~0D~0A~0D~0A// Optional: if we acc
epted a partial and want to freeze size before armi
ng stop~0D~0Aif ($filled == 2 && $cancelRemainderOn
Partial == 1) {~0D~0A    $order.Cancel();~0D~0A    
// brief wait to let the residual cancel~0D~0A    W
ait(200);~0D~0A}~0D~0A~0D~0A// === 6) Arm unified 1
R stop via reusable ~E2~80~9CSet Auto Stop~E2~80~9D
 script ===~0D~0Aif ($useAutoStop == "Yes") {~0D~0A
    ExecHotKey("Set Auto Stop");   ~0D~0A}~0D~0A~0D
~0A// == 7) Build and set take profit trigger (opti
onal) ==~0D~0A// Only (re)build TP if we are NOT al
ready profitable on the existing position.~0D~0A// 
For longs, "profitable" means: BID > avgBefore on t
he position that existed~0D~0A// before this entry.
 If we're already green, do NOT reset TP.~0D~0Aif (
$useTakeProfit == "Yes") {~0D~0A~0D~0A    // If no 
position beforehand, always set TP (fresh trade)~0D
~0A    if ($posBefore <= 0) {~0D~0A        ExecHotK
ey("Set Take Profit");~0D~0A    } else {~0D~0A     
   // We had a long position before this add. Check
 profitability.~0D~0A        $bidNow = BID;~0D~0A~0D
~0A        // If avgBefore is invalid, be conservat
ive and allow TP reset~0D~0A        if ($avgBefore 
<= 0) {~0D~0A            ExecHotKey("Set Take Profi
t");~0D~0A        } else {~0D~0A            // Only
 reset TP if NOT yet profitable (bid <= avgBefore)~0D
~0A            if ($bidNow <= $avgBefore) {~0D~0A  
              ExecHotKey("Set Take Profit");~0D~0A 
           }~0D~0A            // else: already prof
itable ~E2~86~92 do nothing, keep existing TP~0D~0A
        }~0D~0A    }~0D~0A}~0D~0A~0D~0A// --- End -
--
Ctrl+,:Set Global Variables:~ 3532:// =====================~0D~0A//  GLOBAL VARIABLES~0D
~0A// =====================~0D~0A//~0D~0A// IMPORTA
NT:~0D~0A// - Do NOT change this script's name.~0D~0A
// - If you update any global variables, either re-
run this script~0D~0A//   or restart DAS Trader to 
ensure all globals are refreshed.~0D~0A//~0D~0A~0D~0A
// Keep track of how many times our one-second scri
pt as executed~0D~0A$oneSecondScriptCnt = 0;~0D~0A~0D
~0A// Use rehab mode?  Limits trades to ice-breaker
 size (1/4 normal size)~0D~0A$rehab = 1;~0D~0A~0D~0A
// ---- Feature Toggles ----~0D~0A$useSlippageMargi
n = 1;      // 1=guard stop vs bid with margin~0D~0A
$slipTicksMin          = 2;      // minimum ticks t
o add as slippage margin~0D~0A$slipSpreadFrac      
= 0.25;  // additional margin = spread * this fract
ion~0D~0A$acceptPartial                      = 1;  
 // 1 = accept partial within window; 0 = require f
ull fill~0D~0A$minFillShares                     = 
1;   // minimum filled shares to accept when $accep
tPartial=1~0D~0A$cancelRemainderOnPartial  = 1;   /
/ 1=cancel remainder before arming stop when partia
l accepted~0D~0A$usePerTradeRiskCap = 1;      // 1=
abort if projected risk exceeds cap~0D~0A$useSpread
Check = 1;~0D~0A~0D~0A// ==========================
============================~0D~0A//  1) Risk & Exe
cution Variables~0D~0A// ==========================
============================~0D~0A~0D~0A// Entry of
fset above/below bid/ask (depending on strategy)~0D
~0A// Example: 0.01 = enter 1 cent(s) above BID (or
 below ASK)~0D~0A$entryOffset = 0.03;~0D~0A~0D~0A//
 Exit offset above/below bid/ask (depending on stra
tegy)~0D~0A// Example: 0.01 = enter 1 cent(s) above
 BID (or below ASK)~0D~0A$exitOffset = 0.10;~0D~0A~0D
~0A// How far your STOP is from entry, per share, i
n dollars (your "1R")~0D~0A// Example: 0.10 = 10 ce
nts risk per share~0D~0A$stopLossTrigger = 0.10;~0D
~0A~0D~0A// How many R~E2~80~99s ahead to place the
 take-profit alert~0D~0A// Example: 1.0 = take prof
it at +1R~0D~0A$takeProfitFactor = 1.0;~0D~0A~0D~0A
// What portion of your position to sell/cover when
 the TP alert hits~0D~0A// Example: 0.50 = sell hal
f at TP~0D~0A$takeProfitSize = 0.50;~0D~0A~0D~0A// 
===================================================
===~0D~0A//  2) Feature Toggles (Enable/Disable Com
ponents)~0D~0A// ==================================
====================~0D~0A~0D~0A$useAutoStop = "Yes
";~0D~0A$useTakeProfit = "Yes";~0D~0A$resetStopOnCa
ncel = "Yes";~0D~0A~0D~0A// =======================
===============================~0D~0A//  3) Account
 State (Simulation / Live Modes)~0D~0A// ==========
============================================~0D~0A/
/~0D~0A// You can toggle between sim/live elsewhere
 using ACCOUNT_STATE.~0D~0A// These vars store your
 SIM and LIVE account identifiers.~0D~0A~0D~0Aif ($
ACCOUNT_STATE == "") {~0D~0A    $ACCOUNT_STATE = "l
ive";      // default state is SIM mode~0D~0A    $T
RSIM  = "TR19644";         // your SIM trading acco
unt~0D~0A    $TRLIVE = "19644";           // your L
IVE trading account~0D~0A}~0D~0A~0D~0A// ==========
============================================~0D~0A/
/  4) Sizing & Risk Limits~0D~0A// ================
======================================~0D~0A~0D~0A/
/ Multiplier for position sizing~0D~0A// Example: i
f base clip is 50 shares, QTY_MULT=5 ~E2~86~92 200 
shares per entry~0D~0A$qtyMult = 4;~0D~0A~0D~0A// M
aximum allowed position size (shares)~0D~0A$maxPosi
tionSize = $qtyMult * 150;~0D~0A~0D~0A// Maximum al
lowed $ risk *per trade*~0D~0A// Useful for guardin
g against oversized positions or bad spreads~0D~0A$
riskCapDollars = 100.00;~0D~0A~0D~0A// Maximum allo
wed daily loss tracked by comparing~0D~0A// start o
f session equit vs. current equtiy~0D~0A$maxDailyLo
ss = 100.00;~0D~0A~0D~0A// Order Entry Fill Wait Pa
rameters~0D~0A$pollMs           = 100;             
// polling cadence (ms)~0D~0A$maxPolls       = 20; 
             // 20*100ms ~E2~89~88 2s~0D~0A~0D~0AEx
ecHotKey("Initialize Session Equity");
Alt+Ctrl+S:Switch to Sim:~ 855:// =====================~0D~0A// Switch to Sim Mode
~0D~0A// =====================~0D~0A~0D~0A// ---- U
se global STOPLOSS_TRIGGER if set (required) ----~0D
~0Aif ($ACCOUNT_STATE== "") {~0D~0A    ExecHotkey("
Set Global Variables");~0D~0A    if ($ACCOUNT_STATE
== "") {~0D~0A        MsgBox("Global ACCOUNT_STATE 
is not set. Please check your global variable setti
ngs.");~0D~0A    return;~0D~0A    }~0D~0A}~0D~0A~0D
~0Aif  ($ACCOUNT_STATE  == "live") {~0D~0A~0D~0A   
$pos = GetWindowObj("Positions_Sim");~0D~0A   $pos.
AlwaysOnTop;;~0D~0A~0D~0A   $pos = GetWindowObj("Po
sitions_Live");~0D~0A   $pos.AlwaysOnTop;~0D~0A~0D~0A
   FocusWindow Trades;~0D~0A   SetFilter Account TR
19644;~0D~0A   DoFilter;~0D~0A~0D~0A   FocusWindow 
Orders;~0D~0A   SetFilter Account TR19644;~0D~0A   
DoFilter;~0D~0A~0D~0A   FocusWindow Primary_OE;~0D~0A
   Account TR19644;~0D~0A~0D~0A   FocusWindow Secon
dary_OE;~0D~0A   Account TR19644;~0D~0A~0D~0A   $AC
COUNT_STATE = "sim";~0D~0A~0D~0A   ExecHotKey("Init
ialize Session Equity");~0D~0A~0D~0A}
Alt+Ctrl+L:Switch to Live:~ 847:// =====================~0D~0A// Switch to Live Mod
e~0D~0A// =====================~0D~0A~0D~0A// ---- 
Use global STOPLOSS_TRIGGER if set (required) ----~0D
~0Aif ($ACCOUNT_STATE== "") {~0D~0A    ExecHotkey("
Set Global Variables");~0D~0A    if ($ACCOUNT_STATE
== "") {~0D~0A        MsgBox("Global ACCOUNT_STATE 
is not set. Please check your global variable setti
ngs.");~0D~0A    return;~0D~0A    }~0D~0A}~0D~0A~0D
~0Aif ($ACCOUNT_STATE == "sim") {~0D~0A~0D~0A   $po
s = GetWindowObj("Positions_Sim");~0D~0A   $pos.Alw
aysOnTop;;~0D~0A~0D~0A   $pos = GetWindowObj("Posit
ions_Live");~0D~0A   $pos.AlwaysOnTop;;~0D~0A~0D~0A
   FocusWindow Trades;~0D~0A   SetFilter Account 19
644;~0D~0A   DoFilter;~0D~0A~0D~0A   FocusWindow Or
ders;~0D~0A   SetFilter Account 19644;~0D~0A   DoFi
lter;~0D~0A~0D~0A   FocusWindow Primary_OE;~0D~0A  
 Account 19644;~0D~0A~0D~0A   FocusWindow Secondary
_OE;~0D~0A   Account 19644;~0D~0A~0D~0A   $ACCOUNT_
STATE = "live";~0D~0A~0D~0A   ExecHotKey("Initializ
e Session Equity");~0D~0A~0D~0A}
Alt+Ctrl+Win+1:Select Primary Order Entry:~ 157:// =====================~0D~0A// Select Primary Mon
tage~0D~0A// =====================~0D~0A~0D~0AFocus
Window Primary_OE;~0D~0A$c1 = GetWindowObj("Chart_1
m");~0D~0A$c1.Symbol = SYMB;
Ctrl+Shift+T:Set Take Profit:~ 3243:// =====================~0D~0A//  TAKE-PROFIT ALERT
 BUILDER (FACTOR * R, SIZE-AWARE)~0D~0A//   Uses:~0D
~0A//     STOPLOSS_TRIGGER     -> per-share risk (1
R)~0D~0A//     TAKE_PROFIT_FACTOR   -> multiplier o
n R (e.g., 1.0 = 1R | 2.0 = 2R)~0D~0A//     TAKE_PR
OFIT_SIZE     -> portion to take at TP (0.25, 0.50,
 0.75, etc.)~0D~0A// =====================~0D~0A~0D
~0AFocusWindow Primary_OE;~0D~0A~0D~0A// ----------
---------------------------------------------~0D~0A
// 2) Load profit factor (R multiple)~0D~0A// -----
--------------------------------------------------~0D
~0A~0D~0A// Effective TP distance in dollars per sh
are~0D~0A$tpDist = $stopLossTrigger * $takeProfitFa
ctor;~0D~0A~0D~0A// -------------------------------
------------------------~0D~0A// 3) Load current mo
ntage context (Primary_OE)~0D~0A// ----------------
---------------------------------------~0D~0A$mySym
 = Symbol;~0D~0A$myAcc = Account;~0D~0A~0D~0A$accOb
j = GetAccountObj($myAcc);~0D~0A$posNow = $accObj.G
etPosition($mySym).Share;~0D~0A$avgNow = AvgCost;~0D
~0A~0D~0A// No position ~E2~86~92 nothing to alert~0D
~0Aif ($posNow == 0) { return; }~0D~0A~0D~0A// If A
vgCost still initializing, fall back to last sale~0D
~0Aif ($avgNow <= 0) { $avgNow = Last; }~0D~0A~0D~0A
// ------------------------------------------------
-------~0D~0A// 4) Compute the target price~0D~0A//
 --------------------------------------------------
-----~0D~0A$tpPx = $avgNow;~0D~0Aif ($posNow > 0) {
~0D~0A    // Long ~E2~86~92 take partial when price
 goes UP by TP distance~0D~0A    $tpPx = $avgNow + 
$tpDist;~0D~0A} else {~0D~0A    // Short ~E2~86~92 
take partial when price goes DOWN by TP distance~0D
~0A    $tpPx = $avgNow - $tpDist;~0D~0A}~0D~0A~0D~0A
// ------------------------------------------------
-------~0D~0A// 5) Tick-size resolution + snapping~0D
~0A// ---------------------------------------------
----------~0D~0A$inc = 0.01;~0D~0Aif ($tpPx < 1 || 
$avgNow < 1)       { $inc = 0.001; }~0D~0Aif ($tpPx
 < 0.25 || $avgNow < 0.25) { $inc = 0.0005; }~0D~0A
$tpPx = Round($tpPx, 102, $inc);~0D~0A~0D~0A// ----
---------------------------------------------------
~0D~0A// 6) Remove existing TP alert for this symbo
l/factor~0D~0A// ----------------------------------
---------------------~0D~0A$alertName = "TP " + $ta
keProfitFactor + "R Partial " + $mySym;~0D~0A~0D~0A
$toDel = GetAlertObj($alertName);~0D~0Aif (IsObj($t
oDel)) { $toDel.Delete(); }~0D~0A~0D~0A// ---------
----------------------------------------------~0D~0A
// 7) Build the new alert~0D~0A// -----------------
--------------------------------------~0D~0A$al = N
ewAlertObj();~0D~0A$al.Name = $alertName;~0D~0A$al.
Symb = $mySym;~0D~0A~0D~0A// Longs: wait for price 
to go ABOVE TP~0D~0A// Shorts: wait for price to go
 BELOW TP~0D~0Aif ($posNow > 0) {~0D~0A    $al.AddI
tem("Last Sale", ">", $tpPx);~0D~0A} else {~0D~0A  
  $al.AddItem("Last Sale", "<", $tpPx);~0D~0A}~0D~0A
~0D~0A// ------------------------------------------
-------------~0D~0A// 8) Script executed when the a
lert triggers~0D~0A// -----------------------------
--------------------------~0D~0A// This calls the e
xecutor hotkey that uses TAKE_PROFIT_SIZE.~0D~0Awai
t(2000);~0D~0A$al.Script =~0D~0A    "SetVar(\"TP_SY
MBOL\",\"" + $mySym + "\");" +~0D~0A    "FocusWindo
w Primary_OE;" +~0D~0A    "ExecHotkey(\"Take Profit
 Executor\");";~0D~0A~0D~0A$al.Speak       = 0;~0D~0A
$al.PlaySound   = 0;~0D~0A$al.AutoDelete  = 1;~0D~0A
$al.Loop        = 0;~0D~0A$al.PopupWindow = 0;~0D~0A
~0D~0A// ------------------------------------------
-------------~0D~0A// 9) Save / activate alert~0D~0A
// ------------------------------------------------
-------~0D~0A$al.Save();~0D~0A$takeProfitSymbol = $
mySym;
:Take Profit Executor:~ 4994:// =====================~0D~0A//  PARTIAL TAKE-PROF
IT EXECUTION (SIZE-AWARE, LONG ONLY)~0D~0A//   Uses
 TAKE_PROFIT_SIZE global variable~0D~0A//   Flow:~0D
~0A//     1) Use TP_SYMBOL (if set) to ensure Prima
ry_OE is on correct symbol~0D~0A//     2) Cancel ex
isting SELL-side orders (stops/targets)~0D~0A//    
 3) Send partial TP SELL order~0D~0A//     4) Class
ify fill as FULL / PARTIAL / NONE~0D~0A//     5) If
 FULL fill -> re-arm BE stop for remaining shares (
no new TP trigger)~0D~0A//        If NOT full  -> r
e-arm 1R stop AND re-arm TP trigger (if enabled)~0D
~0A// =====================~0D~0A~0D~0A// 0) Ensure
 we're working off Primary_OE context for UI~0D~0AF
ocusWindow Primary_OE;~0D~0A~0D~0A// 2) Get the Pri
mary_OE montage window~0D~0A$M = GetWindowObj("Prim
ary_OE");~0D~0Aif (!IsObj($M)) {~0D~0A    MsgBox("T
ake_Profit_Executor: montage 'Primary_OE' not found
.");~0D~0A    return;~0D~0A}~0D~0A~0D~0A// 2a) Opti
onal: symbol override via TP_SYMBOL from alert~0D~0A
$mySym = $M.Symb;~0D~0A$myAcc = $M.Account;~0D~0A~0D
~0A// If TP_SYMBOL is set and differs from current 
montage symbol, try to switch~0D~0Aif ($takeProfitS
ymbol != "" && $takeProfitSym != $mySym) {~0D~0A   
 $M.Symb = $takeProfitSymbol;        // attempt to 
switch montage symbol~0D~0A    Wait(100);          
                            // allow DAS to update~0D
~0A    $mySym = $M.Symb;~0D~0A    $myAcc = $M.Accou
nt;~0D~0A~0D~0A    // Safety: if we still aren't on
 TP_SYMBOL, abort to avoid touching wrong symbol~0D
~0A    if ($mySym != $takeProfitSymbol) {~0D~0A    
    MsgBox("TP Executor: failed to switch Primary_O
E to " + $takeProfitSymbol +~0D~0A               ".
 Currently on " + $mySym + ". Aborting.");~0D~0A   
     return;~0D~0A    }~0D~0A}~0D~0A~0D~0A// 2b) No
w load position from the (possibly updated) montage
~0D~0A$posNow = $M.Pos;~0D~0A~0D~0A// Safety: make 
sure account is valid~0D~0Aif ($myAcc == "") {~0D~0A
    MsgBox("Take_Profit_Executor: Account is blank 
on Primary_OE. Aborting.");~0D~0A    return;~0D~0A}
~0D~0A~0D~0A// LONG-ONLY: No long position? Exit.~0D
~0Aif ($posNow <= 0) {~0D~0A    return;~0D~0A}~0D~0A
~0D~0A// 3) Cancel existing SELL-side working order
s (stops/targets)~0D~0A$accObj = GetAccountObj($myA
cc);~0D~0A$accObj.CancelOrder("SELL", $mySym, 0);~0D
~0A~0D~0A// Let cancels register~0D~0AWait(300);~0D
~0A~0D~0A// Re-read live position after cancels (in
 case something changed)~0D~0A$posNow = $M.Pos;~0D~0A
if ($posNow <= 0) {~0D~0A    // Flat now (maybe sto
p filled while we were messing around) ~E2~86~92 no
thing to do~0D~0A    return;~0D~0A}~0D~0A~0D~0A// 4
) Compute shares to take (DAS-safe, long-only)~0D~0A
$tpRaw   = ($posNow * $takeProfitSize);~0D~0A$takeQ
ty = Round($tpRaw, 102, 1);      // nearest whole s
hare~0D~0A~0D~0A// Clamp: never more than current p
osition~0D~0Aif ($takeQty > $posNow) { $takeQty = $
posNow; }~0D~0A~0D~0A// Must take at least 1 share 
if position exists~0D~0Aif ($takeQty < 1) { $takeQt
y = $posNow; }~0D~0A~0D~0A// 5) Compute exit price 
(long-only: always SELL at/near bid)~0D~0A$px = $M.
Bid;~0D~0A~0D~0A// Tick-size handling~0D~0A$inc = 0
.01;~0D~0Aif ($px < 1)    { $inc = 0.001; }~0D~0Aif
 ($px < 0.25) { $inc = 0.0005; }~0D~0A$px = Round($
px, 102, $inc);~0D~0A~0D~0A// 6) Send order using N
ewOrderObj()~0D~0A$order = NewOrderObj();~0D~0A$ord
er.Account = $myAcc;  ~0D~0A$order.Symbol  = $mySym
;~0D~0A$order.Side    = "S";     ~0D~0A$order.Type 
 = "L";~0D~0A$order.Price = $px;~0D~0A$order.Share 
= $takeQty;~0D~0A$order.Route = "ARCAL";     ~0D~0A
$order.Tif   = "DAY+";~0D~0A$order.Send();~0D~0A~0D
~0A// 7) Poll for fill / partial fill~0D~0A$pollMs 
         = 100;~0D~0A$maxPolls      = 30;      // u
p to ~7E3s total~0D~0A$filledState     = 0;       /
/ 0 = none, 1 = full, 2 = partial~0D~0A~0D~0A$i = 0
;~0D~0Awhile ($i < $maxPolls) {~0D~0A    Wait($poll
Ms);~0D~0A    $order.GetInfo();    // refresh order
 object~0D~0A~0D~0A    // FULL fill: no remaining o
pen shares on this TP order~0D~0A    if ($order.Ope
n == 0) {~0D~0A        $filledState = 1;~0D~0A     
   break;~0D~0A    }~0D~0A~0D~0A    $i = $i + 1;~0D
~0A}~0D~0A~0D~0A// After polling, classify final st
ate based on what we see~0D~0A$filledQty = $order.S
hare - $order.Open;  // how many filled so far~0D~0A
~0D~0Aif ($filledState != 1) {~0D~0A    if ($filled
Qty > 0 && $order.Open > 0) {~0D~0A        $filledS
tate = 2;   // partial fill~0D~0A    } else {~0D~0A
        $filledState = 0;   // no fill~0D~0A    }~0D
~0A}~0D~0A~0D~0A// Optional debug~0D~0A// MsgBox("F
illedState=" + $filledState + "  FilledQty=" + $fil
ledQty +~0D~0A//        "  Share=" + $order.Share +
 "  Open=" + $order.Open);~0D~0A~0D~0A// Optional: 
small throttle between orders~0D~0A$elapsed = $i * 
$pollMs;~0D~0Aif ($elapsed < 200) {~0D~0A    Wait(2
00 - $elapsed);~0D~0A}~0D~0A~0D~0A// 8) Decide whic
h stop to re-arm & whether to re-arm TP trigger~0D~0A
~0D~0A// Behavior:~0D~0A// - FULL fill (filledState
 == 1):~0D~0A//       ~E2~86~92 re-arm BE stop only
~0D~0A// - NOT full (0 = no fill, 2 = partial fill)
:~0D~0A//       ~E2~86~92 re-arm 1R stop~0D~0A//   
    ~E2~86~92 and re-arm TP trigger (if enabled)~0D
~0Aif ($useAutoStop == "Yes") {~0D~0A~0D~0A    if (
$filledState == 1) {~0D~0A        // FULL TP fill ~E2
~86~92 lock remaining at BE~0D~0A        ExecHotkey
("Set Auto Stop BE");~0D~0A    } else {~0D~0A      
  // No fill OR partial fill ~E2~86~92 re-arm origi
nal 1R stop~0D~0A        ExecHotkey("Set Auto Stop"
);~0D~0A    }~0D~0A}~0D~0A~0D~0A// 9) Re-establish 
take profit alert/trigger if enabled~0D~0A// Only w
hen we did NOT get a FULL TP fill~0D~0AWait(2000);~0D
~0Aif ($useTakeProfit == "Yes") {~0D~0A    if ($fil
ledState != 1) {~0D~0A        ExecHotkey("Set Take 
Profit");~0D~0A    }~0D~0A}~0D~0A~0D~0A// --- End T
ake Profit Executor ---
Ctrl+Shift+B:Set Auto Stop BE 1/1:~ 4013:// =====================~0D~0A//  SET AUTO STOP BE 
(SLP ABOVE BE)~0D~0A// =====================~0D~0A/
/~0D~0A// Called from Take_Profit_Executor~0D~0A// 
Behavior:~0D~0A//   - Protects PARTIAL position (1/
denominator)~0D~0A//   - If not yet +0.03 in profit
 ~E2~86~92 place BE LIMIT sell~0D~0A//   - If >= +0
.03 in profit ~E2~86~92 place SLP stop-limit above 
BE~0D~0A//~0D~0A// Requirements:~0D~0A//   - Primar
y_OE montage exists~0D~0A//   - Uses montage object
 properties (.Symb, .Account, .Pos, .AvgCost)~0D~0A
//   - Honors USE_AUTO_STOP~0D~0A//~0D~0A~0D~0A// =
====================~0D~0A// Tunables~0D~0A// =====
================~0D~0A$portionDenominator = 1;    /
/ 1 = full, 2 = half, 4 = quarter~0D~0A$beOffset   
        = 0.03; // BE trigger offset~0D~0A$cancelWa
itMs       = 1000; // cancel throttle wait~0D~0A~0D
~0A// =====================~0D~0A// 0) Feature togg
le~0D~0A// =====================~0D~0Aif ($useAutoS
top != "Yes") {~0D~0A    return;~0D~0A}~0D~0A~0D~0A
// =====================~0D~0A// 1) Get Primary_OE 
montage~0D~0A// =====================~0D~0A$M = Get
WindowObj("Primary_OE");~0D~0Aif (!IsObj($M)) {~0D~0A
    MsgBox("Set Auto Stop BE: Primary_OE montage no
t found.");~0D~0A    return;~0D~0A}~0D~0A~0D~0A// =
====================~0D~0A// 2) Symbol / account re
solution~0D~0A// =====================~0D~0A$mySym 
= $M.Symb;~0D~0A$myAcc = $M.Account;~0D~0A~0D~0A// 
Optional override from executor~0D~0Aif ($tpSymbol 
!= "" && $tpSymbol != $mySym) {~0D~0A    $M.Symb = 
$tpSymbol;~0D~0A    Wait(300); // allow DAS to full
y update~0D~0A~0D~0A    $mySym = $M.Symb;~0D~0A    
$myAcc = $M.Account;~0D~0A~0D~0A    if ($mySym != $
tpSymbol) {~0D~0A        MsgBox("Set Auto Stop BE: 
failed to switch montage to " + $tpSymbol);~0D~0A  
      return;~0D~0A    }~0D~0A}~0D~0A~0D~0A// Optio
nal entry-symbol safety~0D~0Aif ($entrySymbol != ""
 && $entrySymbol != $mySym) {~0D~0A    MsgBox("Set 
Auto Stop BE: symbol mismatch (" + $mySym + " vs " 
+ $entrySymbol + ")");~0D~0A    return;~0D~0A}~0D~0A
~0D~0A// =====================~0D~0A// 3) Read posi
tion state~0D~0A// =====================~0D~0A$posN
ow = $M.Pos;~0D~0A$avgNow = $M.AvgCost;~0D~0A~0D~0A
if ($posNow <= 0) {~0D~0A    return; // flat or sho
rt~0D~0A}~0D~0Aif ($avgNow <= 0) {~0D~0A    MsgBox(
"Set Auto Stop BE: AvgCost unavailable for " + $myS
ym);~0D~0A    return;~0D~0A}~0D~0A~0D~0A// ========
=============~0D~0A// 4) Tick size logic (single so
urce of truth)~0D~0A// =====================~0D~0A$
inc = 0.01;~0D~0Aif ($avgNow < 1)    { $inc = 0.001
; }~0D~0Aif ($avgNow < 0.25) { $inc = 0.0005; }~0D~0A
~0D~0A$avgSnap = Round($avgNow, 102, $inc);~0D~0A~0D
~0A// =====================~0D~0A// 5) Market state
~0D~0A// =====================~0D~0A$bid = $M.Bid;~0D
~0Aif ($bid <= 0) {~0D~0A    MsgBox("Set Auto Stop 
BE: No valid BID for " + $mySym);~0D~0A    return;~0D
~0A}~0D~0A~0D~0A$beStopTrigger = Round($avgSnap + $
beOffset, 102, $inc);~0D~0A~0D~0A// ===============
======~0D~0A// 6) Quantity to protect (PARTIAL)~0D~0A
// =====================~0D~0A$qtyProtect = $posNow
 / $portionDenominator;~0D~0Aif ($qtyProtect <= 0) 
{~0D~0A    return;~0D~0A}~0D~0A~0D~0A// ===========
==========~0D~0A// 7) ACCOUNT-SCOPED cancel helper~0D
~0A// =====================~0D~0A$accObj = GetAccou
ntObj($myAcc);~0D~0A$accObj.CancelOrder("SELL", $my
Sym, 0);~0D~0AWait($cancelWaitMs);~0D~0A~0D~0A// ==
===================~0D~0A// 8) NOT YET IN PROFIT ~E2
~86~92 BE LIMIT SELL~0D~0A// =====================~0D
~0Aif ($bid < $beStopTrigger) {~0D~0A~0D~0A    // A
RCAL uses penny ticks~0D~0A    $incBE = 0.01;~0D~0A
~0D~0A    $px = Round($avgSnap, 102, $incBE);~0D~0A
~0D~0A    if ($pegToBid == 1 && $bid > $px) {~0D~0A
        $px = Round($bid, 102, $incBE);~0D~0A    }~0D
~0A~0D~0A    $o = NewOrderObj();~0D~0A    $o.Accoun
t = $myAcc;~0D~0A    $o.Symbol  = $mySym;~0D~0A    
$o.Route   = "ARCAL";~0D~0A    $o.Tif     = "DAY+";
~0D~0A    $o.Side    = "S";~0D~0A    $o.Type    = "
L";~0D~0A    $o.Price   = $px;~0D~0A    $o.Share   
= $qtyProtect;~0D~0A    $o.Send();~0D~0A~0D~0A    r
eturn;~0D~0A}~0D~0A~0D~0A// =====================~0D
~0A// 9) IN PROFIT ~E2~86~92 SLP STOP ABOVE BE~0D~0A
// =====================~0D~0A$stop = Round($avgSna
p + $beOffset, 102, $inc);~0D~0A$px   = Round($avgS
nap, 102, $inc);~0D~0A~0D~0A// Ensure SLP validity 
(limit < stop)~0D~0Aif ($px >= $stop) {~0D~0A    $p
x = Round($stop - $inc, 102, $inc);~0D~0A}~0D~0A~0D
~0A$s = NewOrderObj();~0D~0A$s.Account   = $myAcc;~0D
~0A$s.Symbol    = $mySym;~0D~0A$s.Route     = "STOP
";~0D~0A$s.Tif       = "DAY+";~0D~0A$s.Side      = 
"S";~0D~0A$s.Type      = "SLP";~0D~0A$s.StopPrice =
 $stop;~0D~0A$s.Price     = $px;~0D~0A$s.Share     
= $qtyProtect;~0D~0A$s.Send();~0D~0A~0D~0Areturn;~0D
~0A~0D~0A// --- End Set Auto Stop BE ---
Alt+Ctrl+Win+-:Set 0.10 Stop:~ 139:// How far your STOP is from entry, per share, in d
ollars (your "1R")~0D~0A// Example: 0.10 = 10 cents
 risk per share~0D~0A$stopLossTrigger = 0.10;
Alt+Ctrl+Win+=:Set 0.20 Stop:~ 192:// How far your STOP is from entry, per share, in d
ollars (your "1R")~0D~0A// Example: 0.20 = 20 cents
 risk per share~0D~0A$stopLossTrigger = 0.20;~0D~0A
MsgBox("WARNING: stop loss trigger set to $0.20.");
Ctrl+A:Sell 1/1 Ask:~ 112:FocusWindow Primary_OE;~0D~0ACXL ALLSYMB;~0D~0AWait
(100);~0D~0AROUTE="ARCAL";~0D~0APrice=Ask;~0D~0ASha
re=Pos;~0D~0ATIF=DAY+;~0D~0ASELL=Send;
Ctrl+S:Sell 1/2 Ask:~ 116:FocusWindow Primary_OE;~0D~0ACXL ALLSYMB;~0D~0AWait
(100);~0D~0AROUTE="ARCAL";~0D~0APrice=Ask;~0D~0ASha
re=Pos*0.5;~0D~0ATIF=DAY+;~0D~0ASELL=Send;
Ctrl+D:Sell 1/4 Ask:~ 117:FocusWindow Primary_OE;~0D~0ACXL ALLSYMB;~0D~0AWait
(100);~0D~0AROUTE="ARCAL";~0D~0APrice=Ask;~0D~0ASha
re=Pos*0.25;~0D~0ATIF=DAY+;~0D~0ASELL=Send;
Ctrl+Z:Sell 1/1 Bid-:~ 124:FocusWindow Primary_OE;~0D~0ACXL ALLSYMB;~0D~0AWait
(100);~0D~0AROUTE="ARCAL";~0D~0APrice=Bid-$exitOffs
et;~0D~0AShare=Pos;~0D~0ATIF=DAY+;~0D~0ASELL=Send;
Ctrl+X:Sell 1/2 Bid-:~ 128:FocusWindow Primary_OE;~0D~0ACXL ALLSYMB;~0D~0AWait
(100);~0D~0AROUTE="ARCAL";~0D~0APrice=Bid-$exitOffs
et;~0D~0AShare=Pos*0.5;~0D~0ATIF=DAY+;~0D~0ASELL=Se
nd;
Ctrl+C:Sell 1/4 Bid-:~ 129:FocusWindow Primary_OE;~0D~0ACXL ALLSYMB;~0D~0AWait
(100);~0D~0AROUTE="ARCAL";~0D~0APrice=Bid-$exitOffs
et;~0D~0AShare=Pos*0.25;~0D~0ATIF=DAY+;~0D~0ASELL=S
end;
:Initialize Session Equity:~ 1407:// ==============================~0D~0A// RISK INIT
 / ACCOUNT BINDING~0D~0A// ========================
======~0D~0A~0D~0A// Ensure ACCOUNT_STATE is set (s
im/live)~0D~0Aif ($ACCOUNT_STATE == "") {~0D~0A    
// Default to sim if somehow unset~0D~0A    $ACCOUN
T_STATE = "sim";~0D~0A}~0D~0A~0D~0A// Resolve curre
nt account based on ACCOUNT_STATE~0D~0Aif ($ACCOUNT
_STATE == "sim") {~0D~0A    $AccName = "TR19644";  
 // SIM~0D~0A} else {~0D~0A    $AccName = "19644"; 
    // LIVE~0D~0A}~0D~0A~0D~0A// Get current accoun
t object~0D~0A$acc = GetAccountObj($AccName);~0D~0A
~0D~0A// Key names for this account-specific snapsh
ot / lock~0D~0A$eqKey   = "DAY_EQUITY_START_" + $Ac
cName;~0D~0A$lockKey = "TRADING_LOCKED_"   + $AccNa
me;~0D~0A~0D~0A// Try to load existing starting equ
ity for this account~0D~0A$eqStartStr = GetVar($eqK
ey);~0D~0A$eqStart    = $eqStartStr * 1;~0D~0A~0D~0A
// If no saved equity or invalid, snapshot from cur
rent Equity~0D~0Aif ($eqStartStr == "" || $eqStart 
<= 0) {~0D~0A    $eqStart = $acc.Equity;~0D~0A    S
etVar($eqKey, $eqStart);~0D~0A}~0D~0A~0D~0A// Set "
current" globals used by Timer Event and entry guar
ds~0D~0ASetVar("DAY_ACC",          $AccName);~0D~0A
SetVar("DAY_EQUITY_START", $eqStart);~0D~0A~0D~0A//
 Load this account's lock state (default 0 if unset
)~0D~0A$lockStr = GetVar($lockKey);~0D~0Aif ($lockS
tr == "") {~0D~0A    $lockStr = 0;~0D~0A    SetVar(
$lockKey, 0);~0D~0A}~0D~0ASetVar("TRADING_LOCKED", 
$lockStr);~0D~0A~0D~0A// Optional: show info~0D~0A/
/MsgBox("Risk init for " + $AccName +~0D~0A//      
 "\nStart equity: " + $eqStart +~0D~0A//       "\nL
ocked: " + $lockStr);
Alt+Ctrl+E:Session Max Loss Check:~ 657:// ================================~0D~0A// MANUAL 
STARTING EQUITY INPUT~0D~0A// =====================
===========~0D~0A~0D~0A// Ask user for starting equ
ity~0D~0A$val = Input("Enter Starting Equity", "Typ
e your starting equity amount (e.g., 24500.31)");~0D
~0A~0D~0A// If user cancelled or left blank, stop~0D
~0Aif ($val == "" ) {~0D~0A    MsgBox("Starting equ
ity not set.");~0D~0A    return;~0D~0A}~0D~0A~0D~0A
// Convert to number~0D~0A$eq = $val * 1;~0D~0A~0D~0A
// Validate~0D~0Aif ($eq <= 0) {~0D~0A    MsgBox("I
nvalid equity value: " + $val + ". Must be a positi
ve number.");~0D~0A    return;~0D~0A}~0D~0A~0D~0A//
 Store into global variable~0D~0ASetVar("DAY_EQUITY
_START", $eq);~0D~0A~0D~0A// Inform user~0D~0AMsgBo
x("Manual starting equity set to: " + $eq);
Alt+Ctrl+P:Check PnL:~ 1008:// ==============================~0D~0A// SHOW CURR
ENT TRACKED PnL + LOCK STATE~0D~0A// ==============
================~0D~0A~0D~0A~0D~0A// ==============
================~0D~0A// DISPLAY PnL + LOCK STATE~0D
~0A// ==============================~0D~0A~0D~0A// 
We already have $accName, $eqStart, $eqNow, $limit 
from above,~0D~0A// so no need to re-read DAY_ACC/D
AY_EQUITY_START a second time.~0D~0A~0D~0A// Comput
e PnL~0D~0A$netPnL = $eqNow - $eqStart;~0D~0A~0D~0A
// Sign for display~0D~0A$sign = "";~0D~0Aif ($netP
nL > 0) { $sign = "+"; }~0D~0A~0D~0A// Reload lock 
state (in case it just changed above)~0D~0A$lockedS
tr = GetVar($lockKey);~0D~0A$locked    = ($lockedSt
r * 1);~0D~0A~0D~0A// Human-readable lock state~0D~0A
$lockMsg = "Unlocked";~0D~0Aif ($locked == 1) { $lo
ckMsg = "LOCKED (daily loss limit hit)"; }~0D~0A~0D
~0A// Display popup~0D~0AMsgBox(~0D~0A    "Account:
 "      + $accName + "\n" +~0D~0A    "Start Equity:
 $" + $eqStart + "\n" +~0D~0A    "Current Equity: $
" + $eqNow + "\n" +~0D~0A    "Status: "       + $lo
ckMsg + "\n\n" +~0D~0A    "PnL: "          + $sign 
+ "$" + $netPnL + "\n" +~0D~0A    "Max Loss: $"    
+ $maxDailyLoss~0D~0A);
Alt+Ctrl+U:Reset Starting Equity:~ 1322:// ==============================~0D~0A// RESET RIS
K INIT / ACCOUNT BINDING  (with confirmation)~0D~0A
// ==============================~0D~0A~0D~0A// Ens
ure ACCOUNT_STATE is set (sim/live)~0D~0Aif ($ACCOU
NT_STATE == "") {~0D~0A    // Default to sim if som
ehow unset~0D~0A    $ACCOUNT_STATE = "sim";~0D~0A}~0D
~0A~0D~0A// Determine active account~0D~0Aif ($ACCO
UNT_STATE == "sim") {~0D~0A    $AccName = "TR19644"
;   // SIM~0D~0A} else {~0D~0A    $AccName = "19644
";     // LIVE~0D~0A}~0D~0A~0D~0A// --- Confirmatio
n Prompt ---~0D~0A$answer = Input("Confirm Reset", 
~0D~0A                "Type YES to reset PnL baseli
ne for account " + $AccName + ":");~0D~0A~0D~0Aif (
$answer != "YES") {~0D~0A    MsgBox("Reset aborted.
 (You typed: '" + $answer + "')");~0D~0A    return;
~0D~0A}~0D~0A~0D~0A// --- Get account info ---~0D~0A
$acc = GetAccountObj($AccName);~0D~0A~0D~0A// Build
 per-account keys~0D~0A$eqKey   = "DAY_EQUITY_START
_" + $AccName;~0D~0A$lockKey = "TRADING_LOCKED_"   
+ $AccName;~0D~0A~0D~0A// Record new starting equit
y baseline~0D~0A$eqStart = $acc.Equity;~0D~0ASetVar
($eqKey, $eqStart);~0D~0A~0D~0A// Update "current" 
globals used by guard + PnL display~0D~0ASetVar("DA
Y_ACC",          $AccName);~0D~0ASetVar("DAY_EQUITY
_START", $eqStart);~0D~0A~0D~0A// Reset lock state~0D
~0ASetVar($lockKey,        0);~0D~0ASetVar("TRADING
_LOCKED", 0);~0D~0A~0D~0A// Show result~0D~0AMsgBox
("Risk baseline RESET for " + $AccName +~0D~0A     
  "\nStart equity is now: $" + $eqStart +~0D~0A    
   "\nLock state reset to 0");
Alt+Ctrl+.:Show Config:~ 1610:// =====================~0D~0A// DISPLAY CONFIGURAT
ION~0D~0A// =====================~0D~0A~0D~0A// ---
- Feature Toggles ----~0D~0A$msg =~0D~0A"FEATURE TO
GGLES\n" +~0D~0A"-----------------\n" +~0D~0A"useSl
ippageMargin: " + $useSlippageMargin + "\n" +~0D~0A
"slipTicksMin: " + $slipTicksMin + "\n" +~0D~0A"sli
pSpreadFrac: " + $slipSpreadFrac + "\n" +~0D~0A"acc
eptPartial: " + $acceptPartial + "\n" +~0D~0A"minFi
llShares: " + $minFillShares + "\n" +~0D~0A"cancelR
emainderOnPartial: " + $cancelRemainderOnPartial + 
"\n" +~0D~0A"useSpreadCheck:" + $useSpreadCheck + "
\n" +~0D~0A"usePerTradeRiskCap: " + $usePerTradeRis
kCap + "\n\n" +~0D~0A~0D~0A// ---- Risk & Execution
 ----~0D~0A"RISK & EXECUTION\n" +~0D~0A"-----------
------\n" +~0D~0A"entryOffset: $" + $entryOffset + 
"\n" +~0D~0A"exitOffset: $" + $exitOffset + "\n" +~0D
~0A"stopLossTrigger (1R): $" + $stopLossTrigger + "
\n" +~0D~0A"takeProfitFactor: " + $takeProfitFactor
 + "R\n" +~0D~0A"takeProfitSize: " + ($takeProfitSi
ze * 100) + "%\n\n" +~0D~0A~0D~0A// ---- Feature En
ablement ----~0D~0A"FEATURE ENABLEMENT\n" +~0D~0A"-
----------------\n" +~0D~0A"useAutoStop: " + $useAu
toStop + "\n" +~0D~0A"useTakeProfit: " + $useTakePr
ofit + "\n" +~0D~0A"resetStopOnCancel: " + $resetSt
opOnCancel + "\n\n" +~0D~0A~0D~0A// ---- Account St
ate ----~0D~0A"ACCOUNT STATE\n" +~0D~0A"-----------
------\n" +~0D~0A"ACCOUNT_STATE: " + $ACCOUNT_STATE
 + "\n" +~0D~0A"SIM Account: " + $TRSIM + "\n" +~0D
~0A"LIVE Account: " + $TRLIVE + "\n\n" +~0D~0A~0D~0A
// ---- Sizing & Risk Limits ----~0D~0A"SIZING & RI
SK LIMITS\n" +~0D~0A"-----------------\n" +~0D~0A"q
tyMult: " + $qtyMult + "\n" +~0D~0A"maxPositionSize
: " + $maxPositionSize + " shares\n" +~0D~0A"maxRis
k (per trade): $" + $riskCapDollars + "\n" +~0D~0A"
maxDailyLoss: $" + $maxDailyLoss + "\n";~0D~0A~0D~0A
MsgBox($msg);
:Cancel All No Stops:~ 1122:// ======================~0D~0A//  CANCEL ALL NON-S
TOP ORDERS + DELETE TP ALERTS (CURRENT SYMBOL)~0D~0A
// ======================~0D~0A~0D~0A// 0) Make sur
e we're on Primary_OE and can read it~0D~0AFocusWin
dow Primary_OE;~0D~0A$M = GetWindowObj("Primary_OE"
);~0D~0Aif (!IsObj($M)) {~0D~0A    // If we can't a
ccess Primary_OE, we can't safely infer symbol/posi
tion~0D~0A    return;~0D~0A}~0D~0A~0D~0A// Snapshot
 symbol and position BEFORE we cancel orders~0D~0A$
mySym   = $M.Symb;~0D~0A$posNow  = $M.Pos;~0D~0A~0D
~0A// 1) Cancel all orders for current montage symb
ol (this will include stops)~0D~0ACXL ALLSYMB;~0D~0A
~0D~0A// 2) Delete all TP alerts for this symbol ov
er a reasonable R range~0D~0A//    This matches how
 the TP Alert Builder names them:~0D~0A//    "TP " 
+ <factor> + "R Partial " + <symbol>~0D~0A~0D~0A$i 
= 1;~0D~0A// i=1..20  ~E2~86~92 factors: 0.5, 1.0, 
1.5, ..., 10.0~0D~0Awhile ($i <= 20) {~0D~0A    $f 
= ($i * 0.5);   // 0.5, 1, 1.5, 2, ...~0D~0A~0D~0A 
   $name = "TP " + $f + "R Partial " + $mySym;~0D~0A
~0D~0A    $al = GetAlertObj($name);~0D~0A    if (Is
Obj($al)) {~0D~0A        $al.Delete();~0D~0A    }~0D
~0A~0D~0A    $i = $i + 1;~0D~0A}~0D~0A~0D~0A// Opti
onal: confirm~0D~0A// MsgBox("Cancelled all non-sto
p orders and TP alerts for " + $mySym + ".");~0D~0A
~0D~0Areturn;
Alt+Ctrl+Win+T:Toggle Position Window:~ 256:// ==============================~0D~0A// Toggle Vi
sability of Position Windows~0D~0A// ==============
================~0D~0A~0D~0ASetFocus Primary_OE;~0D
~0A~0D~0A$pos = GetWindowObj("Positions_Sim");~0D~0A
$pos.AlwaysOnTop;;~0D~0A~0D~0A$pos = GetWindowObj("
Positions_Live");~0D~0A$pos.AlwaysOnTop;
Alt+Ctrl+Win+[:Set 0.30 Stop:~ 192:// How far your STOP is from entry, per share, in d
ollars (your "1R")~0D~0A// Example: 0.20 = 20 cents
 risk per share~0D~0A$stopLossTrigger = 0.30;~0D~0A
MsgBox("WARNING: stop loss trigger set to $0.30.");
Alt+Ctrl+Win+]:Toggle STP/TP Feature:~ 307://=======================~0D~0A// Toggle stop loss 
/ take profit~0D~0A//=======================~0D~0A~0D
~0Aif ($useAutoStop == "Yes") {~0D~0A   $useAutoSto
p = "No";~0D~0A   $useTakeProfit = "No";~0D~0A   Ms
gBox("WARNING: stop loss and take profit triggers d
isabled.");~0D~0A} else {~0D~0A   $useAutoStop = "Y
es";~0D~0A   $useTakeProfit = "Yes";~0D~0A}
:Set 0.05 Stop:~ 139:// How far your STOP is from entry, per share, in d
ollars (your "1R")~0D~0A// Example: 0.20 = 20 cents
 risk per share~0D~0A$stopLossTrigger = 0.05;
Alt+Ctrl+Win+':Toggle Spread Check Feature:~ 214://=======================~0D~0A// Toggle spread che
ck~0D~0A//=======================~0D~0A~0D~0Aif ($u
seSpreadCheck== 1) {~0D~0A   $useSpreadCheck=0;~0D~0A
   MsgBox("WARNING: spread check disabled.");~0D~0A
} else {~0D~0A   $useSpreadCheck=1;~0D~0A~0D~0A}
Alt+Ctrl+B:Set Auto Stop BE 1/2:~ 4013:// =====================~0D~0A//  SET AUTO STOP BE 
(SLP ABOVE BE)~0D~0A// =====================~0D~0A/
/~0D~0A// Called from Take_Profit_Executor~0D~0A// 
Behavior:~0D~0A//   - Protects PARTIAL position (1/
denominator)~0D~0A//   - If not yet +0.03 in profit
 ~E2~86~92 place BE LIMIT sell~0D~0A//   - If >= +0
.03 in profit ~E2~86~92 place SLP stop-limit above 
BE~0D~0A//~0D~0A// Requirements:~0D~0A//   - Primar
y_OE montage exists~0D~0A//   - Uses montage object
 properties (.Symb, .Account, .Pos, .AvgCost)~0D~0A
//   - Honors USE_AUTO_STOP~0D~0A//~0D~0A~0D~0A// =
====================~0D~0A// Tunables~0D~0A// =====
================~0D~0A$portionDenominator = 2;    /
/ 1 = full, 2 = half, 4 = quarter~0D~0A$beOffset   
        = 0.03; // BE trigger offset~0D~0A$cancelWa
itMs       = 1000; // cancel throttle wait~0D~0A~0D
~0A// =====================~0D~0A// 0) Feature togg
le~0D~0A// =====================~0D~0Aif ($useAutoS
top != "Yes") {~0D~0A    return;~0D~0A}~0D~0A~0D~0A
// =====================~0D~0A// 1) Get Primary_OE 
montage~0D~0A// =====================~0D~0A$M = Get
WindowObj("Primary_OE");~0D~0Aif (!IsObj($M)) {~0D~0A
    MsgBox("Set Auto Stop BE: Primary_OE montage no
t found.");~0D~0A    return;~0D~0A}~0D~0A~0D~0A// =
====================~0D~0A// 2) Symbol / account re
solution~0D~0A// =====================~0D~0A$mySym 
= $M.Symb;~0D~0A$myAcc = $M.Account;~0D~0A~0D~0A// 
Optional override from executor~0D~0Aif ($tpSymbol 
!= "" && $tpSymbol != $mySym) {~0D~0A    $M.Symb = 
$tpSymbol;~0D~0A    Wait(300); // allow DAS to full
y update~0D~0A~0D~0A    $mySym = $M.Symb;~0D~0A    
$myAcc = $M.Account;~0D~0A~0D~0A    if ($mySym != $
tpSymbol) {~0D~0A        MsgBox("Set Auto Stop BE: 
failed to switch montage to " + $tpSymbol);~0D~0A  
      return;~0D~0A    }~0D~0A}~0D~0A~0D~0A// Optio
nal entry-symbol safety~0D~0Aif ($entrySymbol != ""
 && $entrySymbol != $mySym) {~0D~0A    MsgBox("Set 
Auto Stop BE: symbol mismatch (" + $mySym + " vs " 
+ $entrySymbol + ")");~0D~0A    return;~0D~0A}~0D~0A
~0D~0A// =====================~0D~0A// 3) Read posi
tion state~0D~0A// =====================~0D~0A$posN
ow = $M.Pos;~0D~0A$avgNow = $M.AvgCost;~0D~0A~0D~0A
if ($posNow <= 0) {~0D~0A    return; // flat or sho
rt~0D~0A}~0D~0Aif ($avgNow <= 0) {~0D~0A    MsgBox(
"Set Auto Stop BE: AvgCost unavailable for " + $myS
ym);~0D~0A    return;~0D~0A}~0D~0A~0D~0A// ========
=============~0D~0A// 4) Tick size logic (single so
urce of truth)~0D~0A// =====================~0D~0A$
inc = 0.01;~0D~0Aif ($avgNow < 1)    { $inc = 0.001
; }~0D~0Aif ($avgNow < 0.25) { $inc = 0.0005; }~0D~0A
~0D~0A$avgSnap = Round($avgNow, 102, $inc);~0D~0A~0D
~0A// =====================~0D~0A// 5) Market state
~0D~0A// =====================~0D~0A$bid = $M.Bid;~0D
~0Aif ($bid <= 0) {~0D~0A    MsgBox("Set Auto Stop 
BE: No valid BID for " + $mySym);~0D~0A    return;~0D
~0A}~0D~0A~0D~0A$beStopTrigger = Round($avgSnap + $
beOffset, 102, $inc);~0D~0A~0D~0A// ===============
======~0D~0A// 6) Quantity to protect (PARTIAL)~0D~0A
// =====================~0D~0A$qtyProtect = $posNow
 / $portionDenominator;~0D~0Aif ($qtyProtect <= 0) 
{~0D~0A    return;~0D~0A}~0D~0A~0D~0A// ===========
==========~0D~0A// 7) ACCOUNT-SCOPED cancel helper~0D
~0A// =====================~0D~0A$accObj = GetAccou
ntObj($myAcc);~0D~0A$accObj.CancelOrder("SELL", $my
Sym, 0);~0D~0AWait($cancelWaitMs);~0D~0A~0D~0A// ==
===================~0D~0A// 8) NOT YET IN PROFIT ~E2
~86~92 BE LIMIT SELL~0D~0A// =====================~0D
~0Aif ($bid < $beStopTrigger) {~0D~0A~0D~0A    // A
RCAL uses penny ticks~0D~0A    $incBE = 0.01;~0D~0A
~0D~0A    $px = Round($avgSnap, 102, $incBE);~0D~0A
~0D~0A    if ($pegToBid == 1 && $bid > $px) {~0D~0A
        $px = Round($bid, 102, $incBE);~0D~0A    }~0D
~0A~0D~0A    $o = NewOrderObj();~0D~0A    $o.Accoun
t = $myAcc;~0D~0A    $o.Symbol  = $mySym;~0D~0A    
$o.Route   = "ARCAL";~0D~0A    $o.Tif     = "DAY+";
~0D~0A    $o.Side    = "S";~0D~0A    $o.Type    = "
L";~0D~0A    $o.Price   = $px;~0D~0A    $o.Share   
= $qtyProtect;~0D~0A    $o.Send();~0D~0A~0D~0A    r
eturn;~0D~0A}~0D~0A~0D~0A// =====================~0D
~0A// 9) IN PROFIT ~E2~86~92 SLP STOP ABOVE BE~0D~0A
// =====================~0D~0A$stop = Round($avgSna
p + $beOffset, 102, $inc);~0D~0A$px   = Round($avgS
nap, 102, $inc);~0D~0A~0D~0A// Ensure SLP validity 
(limit < stop)~0D~0Aif ($px >= $stop) {~0D~0A    $p
x = Round($stop - $inc, 102, $inc);~0D~0A}~0D~0A~0D
~0A$s = NewOrderObj();~0D~0A$s.Account   = $myAcc;~0D
~0A$s.Symbol    = $mySym;~0D~0A$s.Route     = "STOP
";~0D~0A$s.Tif       = "DAY+";~0D~0A$s.Side      = 
"S";~0D~0A$s.Type      = "SLP";~0D~0A$s.StopPrice =
 $stop;~0D~0A$s.Price     = $px;~0D~0A$s.Share     
= $qtyProtect;~0D~0A$s.Send();~0D~0A~0D~0Areturn;~0D
~0A~0D~0A// --- End Set Auto Stop BE ---
